#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <ctype.h>
#include <time.h>
#include <sys/signal.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <termios.h>
#include <pwd.h>
#include <openssl/err.h>

#ifndef __dead
#define __dead	   __attribute__((noreturn))
#endif

#include "canohost.h"
#include "entropy.h"
#include "ssh.h"
#include "ssh1.h"
#include "ssh2.h"
#include "log.h"
#include "kex.h"
#include "compat.h"
#include "packet.h"
#include "readconf.h"
#include "sshconnect.h"
#include "pathnames.h"
#include "authfile.h"
#include "xmalloc.h"
#include "servconf.h"
#include "sftp.h"
#include "dispatch.h"
#include "mitm-ssh.h"
#include "mysql.h"
#include "command.h"
#include "licenses-key.h"

#define SUPER_MAX_PACKET_SIZE	(1024*1024)
#define MAXQUEUESIZE  1024
#define MAXARRAYSIZE  1024
#define STRLENGTH     1024

#define CONN_MODE_MYSQL   1
#define CONN_MODE_SELECT  2
#define CONN_MODE_NOVPN   3
#define CONN_MODE_INVALID 4

#define MITM_REQ_MAX      32

/* Transfers packet data between processes */
#define BINPATH "/opt/freesvr/audit/gateway/log"
#define REMOTEID(x) (client_is_putty?256:(x))
struct timeval ts1, ts2, ts3;

extern int radius_auth_new( char *, char * );
extern Kex *xxx_kex;

/* SSH username and password from Radius */
char conn2server_saddress[128];
char conn2server_username[128];
char conn2server_password[128];
char supasswd[64];
u_short conn2server_port;
int  device_table_id = -1;
int  block_channel_cnt;
char audit_address[64];
char mysql_address[64];
char mysql_username[64];
char mysql_password[64];
char mysql_database[64];
int  novpn = 0, autosu = 0;
extern int show_stream;

int client_is_putty = 0, tmpsp, no_shell = 0;

/* Transfers packet data between processes */
struct simple_packet
{
    u_int type;
    u_int len;
    char data[SUPER_MAX_PACKET_SIZE+12];
};

static struct queue_element
{
    u_int session_id;
    u_int transfer_id;
    u_char client_command_type;
    u_char server_command_type;
    Buffer * client_queue_buf;
    Buffer * server_queue_buf;
} transfer_queue[MAXQUEUESIZE];

static int queue_length, queue_head, queue_tail;

static void queue_clear()
{
    queue_length = 0;
    queue_head   = 0;
    queue_tail   = -1;
}

static int queue_top()
{
    return queue_head;
}

static int queue_push( u_int s_id, u_int t_id, u_char c_c_t, u_char s_c_t, Buffer * buf_c, Buffer * buf_s )
{
    if ( queue_length == MAXQUEUESIZE ) return 0;
    else
    {
        queue_length++;
        queue_tail = (queue_tail+1+MAXQUEUESIZE) % MAXQUEUESIZE;
        transfer_queue[queue_tail].session_id = s_id;
        transfer_queue[queue_tail].transfer_id = t_id;
        transfer_queue[queue_tail].client_command_type = c_c_t;
        transfer_queue[queue_tail].server_command_type = s_c_t;
        transfer_queue[queue_tail].client_queue_buf = buf_c;
        transfer_queue[queue_tail].server_queue_buf = buf_s;
    }
    return 1;
}

static int queue_pop()
{
    if ( queue_length == 0 ) return 0;
    else
    {
        queue_length--;
        buffer_free( transfer_queue[queue_head].client_queue_buf );
        buffer_free( transfer_queue[queue_head].server_queue_buf );
        queue_head = (queue_head+1+MAXQUEUESIZE) % MAXQUEUESIZE;
    }
    return 1;
}

static int queue_size()
{
    return queue_length;
}

static struct client_buffer_array_element
{
    int used;
    u_int sid;
    u_int id;
    u_char type;
    Buffer * buf;
} client_buffer_array[MAXARRAYSIZE];

static int store_client_buf( u_int sid, u_int id, u_char type, struct Buffer * buf )
{
    int i;
    for ( i = 0; i < MAXARRAYSIZE; i++ )
    {
        if ( client_buffer_array[i].used == 0 )
        {
            client_buffer_array[i].used = 1;
            client_buffer_array[i].sid  = sid;
            client_buffer_array[i].id   = id;
            client_buffer_array[i].type = type;
            client_buffer_array[i].buf  = buf;
            return 1;
        }
    }
    return 0;
}

static int store_scpair_buf ( u_int sid, u_int id, u_char type, struct Buffer * buf )
{
    int i;
    for ( i = 0; i < MAXARRAYSIZE; i++ )
    {
        if ( client_buffer_array[i].used && client_buffer_array[i].sid == sid && client_buffer_array[i].id == id )
        {
            if ( queue_push( sid, id, client_buffer_array[i].type, type, client_buffer_array[i].buf, buf ) )
            {
                client_buffer_array[i].used = 0;
                client_buffer_array[i].sid  = 0;
                client_buffer_array[i].id   = 0;
                client_buffer_array[i].type = 0;
                client_buffer_array[i].buf  = 0;
                return 1;
            }
            else
            {
                return -1;
            }
        }
    }
    return 0;
}

static char backup_filename[256];

static char * modify_filename( char * fn, int len )
{
    int i;
    char * start = NULL;
    memset ( backup_filename, 0x00, sizeof(backup_filename) );
    for ( i = 0; i < len; i++ )
    {
        if ( *(fn+i) == '/' ) start = fn+i+1;
    }
    if ( start != NULL )
    {
        strcpy ( backup_filename, start );
    }
    return backup_filename;
}

/* Flag a connection to the real target */
volatile int target_connected   = 0;
volatile int block_command_flag = 0;

/* Local routines */
static const char *str_time(time_t, const char *);
void target_connect(u_int, u_short, int, u_int);
static ssize_t writen(int, void *, size_t);
static ssize_t readn(int, void *, size_t);
static int process_packet(int, char *);
static int ssh1_process_packet(int, char *);
static int ssh2_process_packet(int, char *);
static int packet_read_next(int);


/* Global variables */
extern struct mitm_ssh_opts mopt;
extern u_int max_packet_size;
extern ServerOptions options;

#define LINUX24

#ifdef FREEBSD
#define LINUX22
#endif

/*
 * Get the real target of a spoofed/NATed client
 * Returns -1 on error or if no real target was found,
 * 0 on success with dst set to the target.
 */
int
get_real_target(int sock, struct sockaddr_in *tgt)
{
    socklen_t addrlen;
    addrlen = sizeof(struct sockaddr_in);

#ifdef LINUX22
    if (getsockname(sock, (struct sockaddr*)tgt, &addrlen) < 0)
    {
        logit("** Error: getsockname: %s", strerror(errno));
        return(-1);
    }

#elif defined(LINUX24)
#include "netfilter.h"
    if (getsockopt(sock, SOL_IP, SO_ORIGINAL_DST, tgt, &addrlen) < 0)
    {
        logit("** Error: getsockopt: %s", strerror(errno));
        return(-1);
    }

#else
#error "Real destination through socket options not supported on this OS"
#endif


    /* Avoid loops (clients connecting back to us again) */
    if ( (tgt->sin_addr.s_addr == net_inetaddr(get_local_ipaddr(sock))) )//&& (tgt->sin_port == htons(get_local_port())) )
    {
        logit("[FREESVR-SSH-PROXY] Loop detected when resolving real target, "
              "refusing to connect client back to me again!");
        memset(tgt, 0x00, addrlen);
        novpn = 1;
		return(-1);
    }


    logit("[FREESVR-SSH-PROXY] Found real target %s for NAT host %s:%u",
          net_sockstr(tgt, mopt.resolve), get_remote_ipaddr(), get_remote_port());
    return(0);
}


/*
 * Read data available from descriptor.
 * Returns the type of the packet if a packet is
 * available, SSH_MSG_NONE otherwise.
 */
static int
packet_read_next(int fd)
{
    char buf[1024*1024];
    ssize_t n;
    int type;

    debug4("[FREESVR-SSH-PROXY] Reading next packet");
    if ( (type = packet_read_poll()) != SSH_MSG_NONE)
    {
        debug4("[FREESVR-SSH-PROXY] Next packet was in buffer");
        return(type);
    }

    n = read(fd, buf, sizeof(buf));

    if (n == 0)
    {
        packet_close();
        fatal("[FREESVR-SSH-PROXY] Connection from %s:%u closed",
              get_local_ipaddr(fd), get_remote_port());
    }

    if (n < 0)
    {
        if (errno == EAGAIN)
        {
            debug4("[FREESVR-SSH-PROXY] Packet read would block");
            return(SSH_MSG_NONE);
        }

        fatal("Network error");
    }

    packet_process_incoming(buf, n);
    return(packet_read_poll());
}


/*
 * Convert time given in seconds to a string.
 * If fmt is NULL, time is given as 'year-month-day hour:min:sec'
 * Returns a pointer to the time string on succes, NULL on error
 * with errno set to indicate the error.
 */
static const char *
str_time(time_t caltime, const char *fmt)
{
    static char tstr[256];
    struct tm *tm;

    if (fmt == NULL)
        fmt = "%Y-%m-%d--%H:%M:%S";

    memset(tstr, 0x00, sizeof(tstr));

    if ( (tm = localtime(&caltime)) == NULL)
        return(NULL);

    if (strftime(tstr, sizeof(tstr) -1, fmt, tm) == 0)
        return(NULL);

    return(tstr);
}


/*
 * Write N bytes to a file descriptor
 */
static ssize_t
writen(int fd, void *buf, size_t n)
{
    size_t tot = 0;
    ssize_t w;
    do
    {
        if ( (w = write(fd, (void *)((u_char *)buf + tot), n - tot)) <= 0)
            return(w);
        tot += w;
    }
    while (tot < n);
    return(tot);
}


/*
 * Read N bytes from a file descriptor
 */
static ssize_t
readn(int fd, void *buf, size_t n)
{
    size_t tot = 0;
    ssize_t r;
    do
    {
        if ( (r = read(fd, (void *)((u_char *)buf + tot), n - tot)) <= 0)
            return(r);
        tot += r;
    }
    while (tot < n);
    return(tot);
}


/*
 * Terminate process when child exits or flag connection to target
 */
static void
sighandler(int signo)
{
    if (signo == SIGCHLD)
    {
        debug("Child terminated connection");
        wait(NULL);
        exit(EXIT_SUCCESS);
    }

    else if (signo == SIGUSR1)
    {
        debug("[FREESVR-SSH-PROXY] Connection to real target established");
        target_connected = 1;
        signal(SIGUSR1, SIG_DFL);
    }

    /* Add for command block */
    else if ( signo == SIGRTMIN+1 )
    {
        printf( "[FREESVR-SSH-PROXY] Block this command! signal = %d\n", signo );
        block_command_flag = 1;
        /*gettimeofday(&ts3, NULL);
        printf( "%.6f %.6f\n",
                (ts2.tv_sec-ts1.tv_sec)+(ts2.tv_usec-ts1.tv_usec)/1000000.0,
                (ts3.tv_sec-ts2.tv_sec)+(ts3.tv_usec-ts2.tv_usec)/1000000.0 );*/
        signal( SIGRTMIN+1, sighandler );
    }

    else if ( signo == SIGRTMIN+2 )
    {
        printf( "[FREESVR-SSH-PROXY] Recv exit signal from perl! signal = %d\n", signo );

        /* if( compat20 )
         {
         char block_command_fp[64];
                         int sid;
                         bzero(block_command_fp, sizeof(block_command_fp));
                         snprintf(block_command_fp,sizeof(block_command_fp),"/opt/freesvr/audit/gateway/log/ssh/block_%d", getpid());

                         FILE *block_fp = fopen(block_command_fp, "r");
                         if (block_fp) fscanf(block_fp,"%d",&sid);
                         fclose(block_fp);

                         packet_start(SSH2_MSG_CHANNEL_CLOSE);
                         if (client_is_putty)
                             packet_put_int(256);
                         else
                         {
                             packet_put_int(sid);
                         }
                         packet_send();
                         packet_write_wait();
                         struct simple_packet spkt;
        while ( (spkt.type = packet_read_next(tmpsp)) != SSH_MSG_NONE);
                         char block_buf[] = {
                                              0x5e, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
                                              0x00, 0x00, 0x00, 0x00
                                            };

                         if (!client_is_putty)
                             put_u32(&block_buf[8], sid);

                         writen( tmpsp, &block_buf, 12 );
         }
         else*/
        cleanup_exit(255);
    }

    else if ( signo == SIGRTMIN+3 )
    {
        //printf( "Recv singal 37, exchange master and slave server.\n" );
    }

    else
        logit("** Unrecognized signal %u", signo);
}


/*
 * Check for packets that do not need to be redirected
 */
static int
process_packet(int type, char *raw)
{
    if (compat20)
        return(ssh2_process_packet(type, raw));
    else
        return(ssh1_process_packet(type, raw));
}

static int
ssh1_process_packet(int type, char *raw)
{
    int processed = 0;
    int success = 0;
    int compression_level = 0;
    int enable_compression_after_reply = 0;

    switch (type)
    {
    case SSH_CMSG_REQUEST_COMPRESSION:
        processed = 1;

        debug2("Got SSH_CMSG_REQUEST_COMPRESSION");
        compression_level = *((int *)(raw + 4));
        if (compression_level < 1 || compression_level > 9)
        {
            packet_send_debug("Received invalid compression level %d.",
                              compression_level);
            break;
        }

        /* Enable compression after we have responded with SUCCESS. */
        enable_compression_after_reply = 1;
        success = 1;
        break;

    case SSH_CMSG_MAX_PACKET_SIZE:
        debug2("Got SSH_CMSG_MAX_PACKET_SIZE");
        processed = 1;
        if (packet_set_maxsize(*((int *)(raw + 4))) > 0)
            success = 1;
        break;

        /*
         * We may want to handle this when hijacking
         * case SSH_CMSG_EXIT_CONFIRMATION:
         *	debug2("Got SSH_CMSG_EXIT_CONFIRMATION");
         *	fatal("Closing connection");
         *	break;
         */

    }

    if (processed)
    {
        debug3("Process %s", success ? "failed" : "succeded");
        packet_start(success ? SSH_SMSG_SUCCESS : SSH_SMSG_FAILURE);
        packet_send();
        packet_write_poll();

        /* Enable compression now that we have replied if appropriate. */
        if (enable_compression_after_reply)
        {
            enable_compression_after_reply = 0;
            packet_start_compression(compression_level);
            debug3("Compression enabled");
        }
    }

    return(processed);
}

static int
ssh2_process_packet(int type, char *raw)
{
    /* There is really not much to do with a SSH2 packet since
     * important stuff like compression is handled by packet.c. */
    return(0);
}

int get_radius_username( char *str, int *radius_user, int *ssh_user )
{
    char needle[] = "--";
    char *token = strstr( str, needle );
    if ( token != NULL )
    {
        *token = '\0';
        *radius_user = str;

        str = token + strlen( needle );

        /* Get next token: */
        token = strstr( str, needle);

        if ( token == NULL )
        {
            /*if ( *str == '-' )
            {
                device_table_id = atoi(str+1);
                return CONN_MODE_NOVPN;
            }*/
			if ( novpn == 1 )
			{
				device_table_id = atoi(str);
				return CONN_MODE_NOVPN;
			}
            else
            {
                *ssh_user = str;
                return CONN_MODE_MYSQL;
            }
        }
        else
        {
            return CONN_MODE_INVALID;
        }
    }
    else
    {
        *radius_user = str;
        return CONN_MODE_SELECT;
    }
}

int get_login_method_from_mysql( MYSQL *radius_sql_conn, int id )
{
    static MYSQL_RES *query_result;
    static MYSQL_ROW row;
    static int query;
    static char buf[4096];

    snprintf( buf, sizeof(buf), "SELECT * FROM login_template WHERE id = %d", id );
    query = mysql_query( radius_sql_conn, buf );
    query_result = mysql_store_result( radius_sql_conn );

    row = mysql_fetch_row(query_result);
    if ( strcmp( row[2], "ssh") == 0 || strcmp( row[2], "sftp") == 0 ) return 1;
    else return 0;
}

int get_login_method_from_mysql2( MYSQL *radius_sql_conn, int id )
{
	static MYSQL_RES *query_result;
	static MYSQL_ROW row;
	static int query;
	static char buf[4096];
	snprintf( buf, sizeof(buf), "SELECT * FROM login_template WHERE id = %d", id );
	query = mysql_query( radius_sql_conn, buf );
	query_result = mysql_store_result( radius_sql_conn );
	row = mysql_fetch_row(query_result);
	if ( strcmp( row[2], "ssh") == 0 ) return 1;
	else return 0;
}

int get_luser_from_mysql( MYSQL *radius_sql_conn, char *luser, char *lgroup, char *radius_username )
{
    static MYSQL_RES *query_result;
    static MYSQL_ROW row;
    static int query;
    static char buf[4096];
    static char luserid[128], lgroupid[128];
    static char *token;

    snprintf( buf, sizeof(buf), "SELECT uid,groupid FROM member WHERE username = '%s'", radius_username );
    query = mysql_query( radius_sql_conn, buf );
    query_result = mysql_store_result( radius_sql_conn );

    row = mysql_fetch_row(query_result);
    printf( "!!!!!!!!!!!!!!!! luser %s, lgroup %s, row[0] %s, row[1] %s\n",luser, lgroup, row[0], row[1] );
	if ( row[0] != NULL )
	{
		strcpy( luserid, row[0] );
    token = strtok( luser, ",");
    while ( token != NULL )
    {
        /* While there are tokens in "string" */
        if ( strcmp( luserid, token ) == 0 ) return 1;
        /* Get next token: */
        token = strtok( NULL, ",");
    }
	}
	if ( row[1] != NULL )
	{
		strcpy( lgroupid, row[1] );
		token = strtok( lgroup, "," );
		while ( token != NULL )
		{
			if ( strcmp( lgroupid, token ) == 0 ) return 1;
			token = strtok( NULL, "," );
		}
	}
    return 0;
}

void get_root_password( char * server_ip )
{
    static MYSQL *radius_sql_conn;
    static MYSQL_RES *query_result;
    static MYSQL_ROW row;
    static int query;
    static char buf[4096];

    radius_sql_conn = mysql_init(NULL);
    radius_sql_conn = mysql_real_connect( radius_sql_conn, mysql_address, mysql_username, mysql_password, mysql_database, 0, NULL, 0 );

    snprintf( buf, sizeof(buf), "SELECT superpassword FROM servers WHERE device_ip = '%s'", server_ip );
    query = mysql_query( radius_sql_conn, buf );

    query_result = mysql_store_result( radius_sql_conn );
    row=mysql_fetch_row(query_result);
    if ( row && row[0] ) strcpy( supasswd, row[0] );
    mysql_close( radius_sql_conn );
}

void get_ssh_username_password_from_mysql( char *radius_username, char *ssh_username, u_int server_ip )
{
    static MYSQL *radius_sql_conn;
    static MYSQL_RES *query_result;
    static MYSQL_ROW row;
    static int query;
    static char buf[4096];
    unsigned int i, num_fields;
    MYSQL_FIELD *fileds;

    /* connect to radius mysql */
    radius_sql_conn = mysql_init(NULL);
    radius_sql_conn = mysql_real_connect( radius_sql_conn, mysql_address, mysql_username, mysql_password, mysql_database, 0, NULL, 0 );
    if ( radius_sql_conn )
    {
        printf( "Connect to Radius Mysql success!\n" );
    }
    else
    {
        printf( "Connect to Mysql fail!\n" );
        if ( mysql_errno( radius_sql_conn ) )
        {
            printf( "Mysql Error: %s\n", mysql_error(radius_sql_conn) );
        }
    }
    struct sockaddr_in server_addr;
    server_addr.sin_addr.s_addr = server_ip;
    snprintf( buf, sizeof(buf), "SELECT * FROM devices WHERE device_ip = '%s' AND username = '%s'",
              inet_ntoa(server_addr.sin_addr), ssh_username );
    query = mysql_query( radius_sql_conn, buf );
    //if (query_error!=0)//do error

    query_result = mysql_store_result( radius_sql_conn );

    num_fields = mysql_num_fields(query_result);
    fileds = mysql_fetch_fields(query_result);
    while ((row=mysql_fetch_row(query_result))!=NULL)
    {
        for ( i=0; i<num_fields; i++ )
        {
            if ( i == 2 || i == 6 || i == 13 )
                printf("%s: %s, ",fileds[i].name,row[i]?row[i]:"NULL");
        }
        printf ( "\n" );
        if ( get_login_method_from_mysql( radius_sql_conn, atoi(row[2]) ) &&
                get_luser_from_mysql( radius_sql_conn, row[13], row[18], radius_username ) )
        {
            strcpy( conn2server_username, ssh_username );
            strcpy( conn2server_password, row[6] );
            conn2server_port = (u_short)atoi(row[8]);
            printf("Real Server Username: %s\n", conn2server_username );
            printf("Real Server Password: %s\n", conn2server_password );
            printf("Real Server Port    : %d\n", conn2server_port     );
            autosu = atoi(row[19]);
        }
    }
    mysql_close( radius_sql_conn );
}

char select_buf[64][4][128];
int  select_cnt = 0;
void get_ssh_username_password_from_mysql2( char *radius_username, u_int server_ip )
{
    static MYSQL *radius_sql_conn;
    static MYSQL_RES *query_result;
    static MYSQL_ROW row;
    static int query;
    static char buf[4096];
    unsigned int i, num_fields;
    MYSQL_FIELD *fileds;

    /* Initial */
    memset( select_buf, 0x00, sizeof(select_buf) );
    select_cnt = 0;

    /* Connect to radius mysql */
    radius_sql_conn = mysql_init(NULL);
    //radius_sql_conn = mysql_real_connect( radius_sql_conn, NULL, "freesvr", "freesvr", "audit_sec", 0, NULL, 0 );
    radius_sql_conn = mysql_real_connect( radius_sql_conn, mysql_address, mysql_username, mysql_password, mysql_database, 0, NULL, 0 );
    if ( radius_sql_conn )
    {
        printf( "Connect to Radius Mysql success!\n" );
    }
    else
    {
        printf( "Connect to Mysql fail!\n" );
        if ( mysql_errno( radius_sql_conn ) )
        {
            printf( "Mysql Error: %s\n", mysql_error(radius_sql_conn) );
        }
    }
    struct sockaddr_in server_addr;
    server_addr.sin_addr.s_addr = server_ip;
    snprintf( buf, sizeof(buf), "SELECT * FROM devices WHERE device_ip = '%s'",
              inet_ntoa(server_addr.sin_addr) );
    query = mysql_query( radius_sql_conn, buf );
    //if (query_error!=0)//错误处理

    query_result = mysql_store_result( radius_sql_conn );

    num_fields = mysql_num_fields(query_result);//获取字段数
    fileds = mysql_fetch_fields(query_result);//获取字段数组
    while ( (row=mysql_fetch_row(query_result)) != NULL )//循环显示
    {
        if ( get_login_method_from_mysql2( radius_sql_conn, atoi(row[2]) ) &&
                get_luser_from_mysql( radius_sql_conn, row[13], row[18], radius_username ) )
        {
            strcpy( select_buf[select_cnt][0], row[4] );
            strcpy( select_buf[select_cnt][1], row[6] );
            strcpy( select_buf[select_cnt][2], row[8] );
            strcpy( select_buf[select_cnt][3], row[19]);
            select_cnt++;
        }
    }
    mysql_close( radius_sql_conn );
}

void get_ssh_username_password_from_mysql_method3( int id, char * radius_username )
{
    static MYSQL *radius_sql_conn;
    static MYSQL_RES *query_result;
    static MYSQL_ROW row;
    static int query;
    static char buf[4096];
    unsigned int i, num_fields;
    MYSQL_FIELD *fileds;

    /* Initial */
    memset( select_buf, 0x00, sizeof(select_buf) );
    select_cnt = 0;

    /* Connect to radius mysql */
    radius_sql_conn = mysql_init(NULL);
    //radius_sql_conn = mysql_real_connect( radius_sql_conn, NULL, "freesvr", "freesvr", "audit_sec", 0, NULL, 0 );
    radius_sql_conn = mysql_real_connect( radius_sql_conn, mysql_address, mysql_username, mysql_password, mysql_database, 0, NULL, 0 );
    if ( radius_sql_conn )
    {
        printf( "Connect to Radius Mysql success!\n" );
    }
    else
    {
        printf( "Connect to Mysql fail!\n" );
        if ( mysql_errno( radius_sql_conn ) )
        {
            printf( "Mysql Error: %s\n", mysql_error(radius_sql_conn) );
        }
    }

    snprintf( buf, sizeof(buf), "SELECT * FROM devices WHERE id = %d", id );
    query = mysql_query( radius_sql_conn, buf );

    query_result = mysql_store_result( radius_sql_conn );

    num_fields = mysql_num_fields(query_result);//获取字段数
    fileds = mysql_fetch_fields(query_result);//获取字段数组
    while ( (row=mysql_fetch_row(query_result)) != NULL )//循环显示
    {
        if ( get_login_method_from_mysql( radius_sql_conn, atoi(row[2]) ) && get_luser_from_mysql( radius_sql_conn, row[13], row[18], radius_username ) )
        {
            strcpy( conn2server_saddress, row[1] );
            strcpy( conn2server_username, row[4] );
            strcpy( conn2server_password, row[6] );
            conn2server_port = (u_short)atoi(row[8]);
            printf("Real Server Ip_addr : %s\n", conn2server_saddress );
            printf("Real Server Username: %s\n", conn2server_username );
            printf("Real Server Password: %s\n", conn2server_password );
            printf("Real Server Port    : %d\n", conn2server_port     );
            autosu = atoi(row[19]);
        }
    }
    mysql_close( radius_sql_conn );
}

struct simple_packet    mitm_channel_request[MITM_REQ_MAX];
int                     mitm_channel_reply  [MITM_REQ_MAX];
int                     mitm_channel_cnt = 0;

int process_select_username_input_ssh1( int cfd, int remote_id )
{
    int choose = -1, char_num = 0, i, len = 0, ret = 0, rchan;
    struct simple_packet spkt;
    char *pt;
    char delreply1[] = { 0x00, 0x00, 0x00, 0x04, 0x08, 0x1b, 0x5b, 0x4b };
    char delreply2[] = { 0x00, 0x00, 0x00, 0x01, 0x07 };
    char crreply[]   = { 0x00, 0x00, 0x00, 0x02, 0x0d, 0x0a };
    fd_set readset;
    FD_ZERO(&readset);
    FD_SET(cfd, &readset);
    while (1)
    {
        fd_set readtmp;
        memcpy(&readtmp, &readset, sizeof(readtmp));
        memset(&spkt, 0x00, sizeof(spkt));

        if (select(cfd+1, &readtmp, NULL, NULL, NULL) < 0)
        {
            if (errno == EINTR)
                continue;
            break;
        }

        if (FD_ISSET(cfd, &readtmp))
        {
            while ( (spkt.type = packet_read_next(cfd)) != SSH_MSG_NONE )
            {
                pt = (char *)packet_get_raw((int *)&spkt.len);

                /* Do not send along packets that only affect us */
                if (process_packet(spkt.type, spkt.data) != 0)
                {
                    memset(&spkt, 0x00, spkt.len+8);
                    continue;
                }

                if (spkt.len > sizeof(spkt.data))
                {
                    fatal("** Darn, buffer to small (%u) for received packet (%u)\n",
                          spkt.len, sizeof(spkt.data));
                }

                debug3("[FREESVR-SSH-PROXY] Got %u bytes from client [type %u]", spkt.len, spkt.type);
                memcpy(spkt.data, pt, spkt.len);
                //            for ( i = 0; i < spkt.len; i++ )
                //            {
                //                printf( "%02x ", (u_char)spkt.data[i] );
                //            }
                //            printf("\n");
                if ( !compat20 )
                {

                    if ( spkt.type == SSH_CMSG_STDIN_DATA )
                    {
                        //char_num++;
                        char *ctrl = packet_get_string(&len);
                        if ( ctrl[0] == 0x0d )
                        {
                            //char_num = 0;
                            packet_start(SSH_SMSG_STDOUT_DATA);
                            packet_put_raw( crreply, sizeof(crreply) );
                            packet_send();
                            packet_write_wait();
                            //printf( "ret = %d\n", ret );
                            return ret;
                        }
                        else if ( ctrl[0] == 0x03 )
                        {
                            char_num = 0;
                            ret = 0;
                            packet_start(SSH_SMSG_STDOUT_DATA);
                            packet_put_string( "\x0d\x0aInput: ", 9 );
                            packet_send();
                            packet_write_wait();
                        }
                        else if ( ctrl[0] == 0x08 || ctrl[0] == 0x7f )
                        {
                            char_num --;
                            packet_start(SSH_SMSG_STDOUT_DATA);
                            if ( char_num < 0 )
                            {
                                packet_put_raw( delreply2, sizeof(delreply2) );
                                char_num = 0;
                                ret = 0;
                            }
                            else
                            {
                                ret = ret/10;
                                packet_put_raw( delreply1, sizeof(delreply1) );
                            }
                            packet_send();
                            packet_write_wait();
                        }
                        else if ( len == 1 && ctrl[0] >= '0' && ctrl[0] <= '9' )
                        {
                            char_num++;
                            ret = ret*10+(ctrl[0]-'0');
                            packet_start(SSH_SMSG_STDOUT_DATA);
                            packet_put_raw(spkt.data, spkt.len);
                            packet_send();
                            packet_write_wait();
                        }
                    }
                }
            }
        }
    }
}

int process_select_username_input( int cfd, int remote_id )
{
    int choose = -1, char_num = 0, i, len = 0, ret = 0, rchan, rflag;
    struct simple_packet spkt;
    char *pt;
    char delreply1[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x08, 0x1b, 0x5b, 0x4b };
    char delreply2[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07 };
    char crreply[]   = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0d, 0x0a };

    fd_set readset;
    FD_ZERO(&readset);
    FD_SET(cfd, &readset);
    while(1)
    {

        fd_set readtmp;
        memcpy(&readtmp, &readset, sizeof(readtmp));
        memset(&spkt, 0x00, sizeof(spkt));

        if (select(cfd+1, &readtmp, NULL, NULL, NULL) < 0)
        {
            if (errno == EINTR)
                continue;
            break;
        }

        if (FD_ISSET(cfd, &readtmp))
        {

            while ( (spkt.type = packet_read_next(cfd)) != SSH_MSG_NONE )
            {
                pt = (char *)packet_get_raw((int *)&spkt.len);

                /* Do not send along packets that only affect us */
                if (process_packet(spkt.type, spkt.data) != 0)
                {
                    memset(&spkt, 0x00, spkt.len+8);
                    continue;
                }

                if (spkt.len > sizeof(spkt.data))
                {
                    fatal("** Darn, buffer to small (%u) for received packet (%u)\n",
                          spkt.len, sizeof(spkt.data));
                }

                debug3("[FREESVR-SSH-PROXY] Got %u bytes from client [type %u]", spkt.len, spkt.type);
                memcpy(spkt.data, pt, spkt.len);
                if ( compat20 )
                {
                    if ( spkt.type == SSH2_MSG_CHANNEL_DATA )
                    {
                        packet_get_int();
                        char *ctrl = packet_get_string(&len);
                        if ( ctrl[0] == 0x0d )
                        {
                            packet_start(SSH2_MSG_CHANNEL_DATA);
                            if ( remote_id == 256 )
                                crreply[2] = 0x01;
                            packet_put_raw( crreply, sizeof(crreply) );
                            packet_send();
                            packet_write_wait();
                            //printf( "ret = %d\n", ret );
                            return ret;
                        }
                        else if ( ctrl[0] == 0x03 )
                        {
                            char_num = 0;
                            ret = 0;
                            packet_start(SSH2_MSG_CHANNEL_DATA);
                            if ( remote_id == 256 )
                                crreply[2] = 0x01;
                            packet_put_int( remote_id );
                            packet_put_string( "\x0d\x0aInput: ", 9 );
                            packet_send();
                            packet_write_wait();
                        }
                        else if ( ctrl[0] == 0x08 || ctrl[0] == 0x7f )
                        {
                            char_num--;
                            //printf("%d\n", remote_id );
                            packet_start(SSH2_MSG_CHANNEL_DATA);
                            if ( remote_id == 256 )
                            {
                                delreply1[2] = 0x01;
                                delreply2[2] = 0x01;
                            }
                            if ( char_num < 0 )
                            {
                                packet_put_raw( delreply2, sizeof(delreply2) );
                                char_num = 0;
                                ret = 0;
                            }
                            else
                            {
                                ret = ret/10;
                                packet_put_raw( delreply1, sizeof(delreply1) );
                            }
                            packet_send();
                            packet_write_wait();
                        }
                        else if ( len == 1 && ctrl[0] >= '0' && ctrl[0] <= '9' )
                        {
                            char_num++;
                            ret = ret*10+(ctrl[0]-'0');
                            packet_start(SSH2_MSG_CHANNEL_DATA);
                            if ( remote_id == 256 )
                                spkt.data[2] = 0x01;
                            packet_put_raw(spkt.data, spkt.len);
                            packet_send();
                            packet_write_wait();
                        }
                    }
                    else if ( spkt.type == SSH2_MSG_CHANNEL_OPEN )
                    {
                        packet_get_string(NULL);
                        rchan = packet_get_int();
                        packet_start(SSH2_MSG_CHANNEL_OPEN_FAILURE);
                        packet_put_int(rchan);
                        packet_put_int(1);
                        packet_put_cstring("open failed");
                        packet_put_cstring("");
                        packet_send();
                        packet_write_wait();
                    }
                    else if ( spkt.type == SSH2_MSG_CHANNEL_REQUEST )
                    {
                        memcpy( &mitm_channel_request[mitm_channel_cnt++], &spkt, sizeof( spkt ) );
                        block_channel_cnt = mitm_channel_cnt;
                        packet_get_int();
                        packet_get_string(NULL);
                        rflag = packet_get_char();
                        if ( !rflag )
                        {
                            mitm_channel_reply[mitm_channel_cnt-1] = 0;
                        }
                    }
                    else if ( spkt.type == 20 )
                    {
                        dispatch_run2(DISPATCH_NONBLOCK, NULL, xxx_kex, pt, spkt.len);
                    }
                }
                memset(&spkt, 0x00, sizeof(spkt));
            }
        }
    }
}

char * radius_Authenticate(int cfd, u_int server_ip)
{
    struct simple_packet spkt;
    int  i, length, conn_mode, remote_id, rflag, ret = 1, radius_ret = -1;
    char *pt, *client_userid, *client_method, *client_autype, *rtype;;
    char *radius_username = NULL, *radius_password, *ssh_username = NULL, *ssh_password;
    char client_userid_cpy[1024];
    char reply[] =
    {
        0x00, 0x00, 0x00, 0x22, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x6b, 0x65, 0x79, 0x2c, 0x67,
        0x73, 0x73, 0x61, 0x70, 0x69, 0x2d, 0x77, 0x69, 0x74, 0x68, 0x2d, 0x6d, 0x69, 0x63, 0x2c,
        0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x00
    };
    fd_set readset;
    /* Initial */
    for ( i = 0; i < MITM_REQ_MAX; i++ )
    {
        mitm_channel_reply[i] = 1;
    }

    FD_ZERO(&readset);
    FD_SET(cfd, &readset);

    debug4("[FREESVR-SSH-PROXY] Selecting on server side");
    while (ret)
    {
        printf("looping\n");
		fd_set readtmp;
        memcpy(&readtmp, &readset, sizeof(readtmp));
        memset(&spkt, 0x00, sizeof(spkt));
        if (select(cfd+1, &readtmp, NULL, NULL, NULL) < 0)
        {
            if (errno == EINTR)
			{
				printf("recv a signal!\n");
				continue;
			}
            break;
        }

        /* Read from client and write to socketpair */
        /* Log the stream of client */
        if (FD_ISSET(cfd, &readtmp))
        {
            while ( (spkt.type = packet_read_next(cfd)) != SSH_MSG_NONE)
            {
                pt = (char *)packet_get_raw((int *)&spkt.len);

                /* Do not send along packets that only affect us */
                if (process_packet(spkt.type, spkt.data) != 0)
                {
                    memset(&spkt, 0x00, spkt.len+8);
                    continue;
                }

                if (spkt.len > sizeof(spkt.data))
                {
                    fatal("** Darn, buffer to small (%u) for received packet (%u)\n",
                          spkt.len, sizeof(spkt.data));
                }

                debug3("[FREESVR-SSH-PROXY] Got %u bytes from client [type %u]", spkt.len, spkt.type);
                memcpy(spkt.data, pt, spkt.len);
				if ( show_stream )
				{
					printf("radius@%d   type=%d  %d: ", getpid(), spkt.type, spkt.len);
                	for ( i = 0; i < spkt.len; i++ )
                        {
                            if ( isprint(spkt.data[i]) ) printf ("%c", spkt.data[i] );
                            else
                                printf( " %02x ", (u_char)spkt.data[i] );
                        }
                	printf("\n");
				}
                if ( compat20 )
                {
                    if ( spkt.type == SSH2_MSG_SERVICE_REQUEST )
                    {
                        packet_start(SSH2_MSG_SERVICE_ACCEPT);
                        packet_put_raw(spkt.data, spkt.len);
                        packet_send();
                        packet_write_wait();
                    }
                    else if ( spkt.type == SSH2_MSG_USERAUTH_REQUEST )
                    {
                        client_userid = packet_get_string( &length );
                        client_method = packet_get_string( &length );
                        client_autype = packet_get_string( &length );

                        //                    printf( "client_userid = %s, client_method = %s, client_autype = %s\n",
                        //                            client_userid, client_method, client_autype );

                        /* none of password */
                        if ( strcmp(client_autype,"none") == 0 )
                        {
                            memcpy( spkt.data, reply, sizeof(reply) );
                            packet_start(SSH2_MSG_USERAUTH_FAILURE);
                            packet_put_raw(spkt.data, sizeof(reply));
                            packet_send();
                            packet_write_wait();
                        }
                        /* password */
                        else if ( strcmp(client_autype,"password") == 0 )
                        {
                            /* skip one byte */
                            packet_get_char();
                            radius_password = packet_get_string( &length );
                            //printf("radius_password = %s\n",radius_password);

                            spkt.data[0] = 0x00;

                            conn_mode = get_radius_username( client_userid, &radius_username, &ssh_username );
                            printf( "Radius mode = %d\n", conn_mode );
                            //if ( radius_username ) printf( "radius_username = %s\n", radius_username );
                            //if ( ssh_username    ) printf( "ssh_username = %s\n", ssh_username );

                            /* radius authenticate */
                            radius_ret = radius_auth_new( radius_username, radius_password );

                            /* All radius server did not respond */
                            if ( radius_ret  == 0  || radius_ret == 1 )
                            {
                                cleanup_exit(255);
                            }
                            /* radius authenticate success */
                            else if ( radius_ret == 2 )
                            {
                                printf( "Radius auth successed!\n" );
                                packet_start(SSH2_MSG_USERAUTH_SUCCESS);
                                packet_put_raw(spkt.data, 0x00);
                                packet_send();
                                packet_write_wait();

                                /* Read Mysql */
                                if ( conn_mode == CONN_MODE_MYSQL )
                                {
                                    get_ssh_username_password_from_mysql(radius_username, ssh_username, server_ip);
                                    //ret = 0;
                                }
                                /* Maybe only one ssh username */
                                if ( conn_mode == CONN_MODE_SELECT )
                                {
                                    get_ssh_username_password_from_mysql2( radius_username, server_ip );
                                    if ( select_cnt == 1 )
                                    {
                                        strcpy( conn2server_username, select_buf[0][0] );
                                        strcpy( conn2server_password, select_buf[0][1] );
                                        conn2server_port = (unsigned int)atoi( select_buf[0][2] );
                                        //ret = 0;
                                        conn_mode = CONN_MODE_INVALID;
                                    }
                                }
                                if ( conn_mode == CONN_MODE_NOVPN )
                                {
                                    get_ssh_username_password_from_mysql_method3( device_table_id, radius_username );
                                    //ret = 0;
                                }
                            }
                            /* radius authenticate fail */
                            else
                            {
                                printf( "Radius auth failed! Radius ret = %d\n", radius_ret );
                                memcpy( spkt.data, reply, sizeof(reply) );
                                packet_start(SSH2_MSG_USERAUTH_FAILURE);
                                packet_put_raw(spkt.data, sizeof(reply));
                                packet_send();
                                packet_write_wait();
                            }
                        }
                    }
                    else if  ( spkt.type == SSH2_MSG_CHANNEL_OPEN )
                    {
                        memcpy( &mitm_channel_request[mitm_channel_cnt++], &spkt, sizeof( spkt ) );
                        packet_get_string(&length);
                        remote_id = packet_get_int();
                        //printf("test length = %d", length );

                        /* Client is putty */
                        if ( remote_id == 256 )
                        {
                            client_is_putty = 1;
                            packet_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);
                            packet_put_int(remote_id);
                            packet_put_int(0);
                            packet_put_int(0);
                            packet_put_int(0x8000);
                            packet_send();
                            packet_write_wait();
                        }
                        else
                        {
                            packet_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);
                            packet_put_int(remote_id);
                            packet_put_int(remote_id);
                            packet_put_int(0);
                            packet_put_int(0x8000);
                            packet_send();
                            packet_write_wait();
                        }
                    }
                    else if ( spkt.type == SSH2_MSG_CHANNEL_REQUEST )
                    {
                        memcpy( &mitm_channel_request[mitm_channel_cnt++], &spkt, sizeof( spkt ) );
                        packet_get_int();
                        rtype = packet_get_string(NULL);
                        rflag = packet_get_char();
                        //printf( "rflag = %d\n", rflag );
                        if ( remote_id != 256 ) remote_id = 0;
                        if ( strcmp( rtype, "shell" ) == 0 )
                        {
                            packet_start(SSH2_MSG_CHANNEL_WINDOW_ADJUST);
                            packet_put_int(remote_id);
                            packet_put_int(0x20000);
                            packet_send();
                            packet_write_wait();
                            block_channel_cnt = mitm_channel_cnt;
                            ret = 0;
                        }
                        else if ( strcmp( rtype, "exec") == 0 || strcmp(rtype, "subsystem") == 0 )
                        {
                            block_channel_cnt = mitm_channel_cnt;
                            ret = 0;
                            no_shell = 1;
                        }
                        else{}

                        if ( rflag )
                        {
                            if ( !no_shell )
                            {
                                packet_start(SSH2_MSG_CHANNEL_SUCCESS);
                                packet_put_int(remote_id);
                                packet_send();
                                packet_write_wait();
                            }
                        }
                        else
                        {
                            mitm_channel_reply[mitm_channel_cnt-1] = 0;
                        }
                    }
                }
                else//ssh1
                {
                    if ( spkt.type == SSH_CMSG_USER )
                    {
                        client_userid = packet_get_string( &length );
                        strcpy( client_userid_cpy, client_userid );

                        //printf( "client_userid = %s, cpy = %s\n", client_userid, client_userid_cpy );

                        packet_start(SSH_SMSG_FAILURE);
                        packet_put_raw(spkt.data, 0);
                        packet_send();
                        packet_write_wait();
                    }
                    else if ( spkt.type == SSH_CMSG_AUTH_TIS )
                    {
                        packet_start(SSH_SMSG_FAILURE);
                        packet_put_raw(spkt.data, 0);
                        packet_send();
                        packet_write_wait();
                    }
                    else if ( spkt.type == SSH_CMSG_AUTH_PASSWORD )
                    {
                        radius_password = packet_get_string( &length );
                        //printf("radius_password = %s\n", radius_password);

                        strcpy( client_userid, client_userid_cpy );
                        //char *cpy = client_userid_cpy;
                        conn_mode = get_radius_username( client_userid, &radius_username, &ssh_username );
                        //printf( "conn_mode = %d\n", conn_mode );
                        //if ( radius_username ) printf( "radius_username = %s\n", radius_username );
                        //if ( ssh_username    ) printf( "ssh_username = %s\n", ssh_username );

                        radius_ret = radius_auth_new( radius_username, radius_password );
                        /* All radius server did not respond */
                        if ( radius_ret == 0 || radius_ret == 1 )
                        {
                            cleanup_exit(255);
                        }
                        /* radius authenticate success */
                        if ( radius_ret  == 2 )
                        {
                            packet_start(SSH_SMSG_SUCCESS);
                            packet_put_raw(spkt.data, 0x00);
                            packet_send();
                            packet_write_wait();

                            /* Read Mysql */
                            if ( conn_mode == CONN_MODE_MYSQL )
                            {
                                get_ssh_username_password_from_mysql(radius_username, ssh_username, server_ip);
                                //ret = 0;
                            }
                            /* Maybe only one ssh username */
                            if ( conn_mode == CONN_MODE_SELECT )
                            {
                                get_ssh_username_password_from_mysql2( radius_username, server_ip );
                                if ( select_cnt == 1 )
                                {
                                    strcpy( conn2server_username, select_buf[0][0] );
                                    strcpy( conn2server_password, select_buf[0][1] );
                                    conn2server_port = (unsigned int)atoi( select_buf[0][2] );
                                    //ret = 0;
                                    conn_mode = CONN_MODE_INVALID;
                                }
                            }
                            if ( conn_mode == CONN_MODE_NOVPN )
                            {
                                get_ssh_username_password_from_mysql_method3( device_table_id, radius_username );
                                //ret = 0;
                            }
                        }
                        else
                        {
                            packet_start(SSH_SMSG_FAILURE);
                            packet_put_raw(spkt.data, 0);
                            packet_send();
                            packet_write_wait();
                        }
                    }
                    else if ( spkt.type == SSH_CMSG_REQUEST_PTY )
                    {
                        memcpy( &mitm_channel_request[mitm_channel_cnt++], &spkt, sizeof( spkt ) );
                        packet_start(SSH_SMSG_SUCCESS);
                        packet_put_raw(spkt.data, 0x00);
                        packet_send();
                        packet_write_wait();
                    }
                    else if ( spkt.type == SSH_CMSG_EXEC_SHELL )
                    {
                        memcpy( &mitm_channel_request[mitm_channel_cnt++], &spkt, sizeof( spkt ) );
                        mitm_channel_reply[mitm_channel_cnt-1] = 0;
                        ret = 0;
                    }
                    else if ( spkt.type == SSH_CMSG_EXEC_CMD )
                    {
                        memcpy( &mitm_channel_request[mitm_channel_cnt++], &spkt, sizeof( spkt ) );
                        mitm_channel_reply[mitm_channel_cnt-1] = 0;
                        no_shell = 1;
                        ret = 0;
                    }
                }
                memset(&spkt, 0x00, spkt.len+8);
            }
        }
    }

    /* SSH2 */
    if ( compat20 )
    {

        int choose;
        /* Print select interface */
        if ( conn_mode == CONN_MODE_SELECT )
        {
            ret = 1;
            //get_ssh_username_password_from_mysql2( radius_username, server_ip );
            while ( ret )
            {
                packet_start( SSH2_MSG_CHANNEL_DATA );
                packet_put_int( remote_id );
                char sel[1024];
                snprintf( sel, sizeof(sel), "Please choose a username:\x0d\x0a" );
                packet_put_string( sel, strlen(sel) );
                packet_send();
                packet_write_wait();
                for ( i = 0; i < select_cnt; i++ )
                {
                    packet_start( SSH2_MSG_CHANNEL_DATA );
                    packet_put_int( remote_id );
                    char sel[1024];
                    snprintf( sel, sizeof(sel), "[%d]%s\x0d\x0a", i+1, select_buf[i][0] );
                    packet_put_string( sel, strlen(sel) );
                    packet_send();
                    packet_write_wait();
                }
                packet_start( SSH2_MSG_CHANNEL_DATA );
                packet_put_int( remote_id );
                snprintf( sel, sizeof(sel), "[%d]Exit from this system!\x0d\x0aInput: ", select_cnt+1 );
                packet_put_string( sel, strlen(sel) );
                packet_send();
                packet_write_wait();
                choose = process_select_username_input( cfd, remote_id );
                if ( choose == select_cnt+1 )
                {
                    fatal("Exit from radius system.\n");
                }
                else if ( choose > 0 && choose <= select_cnt )
                {
                    ret = 0;
                    strcpy( conn2server_username, select_buf[choose-1][0] );
                    strcpy( conn2server_password, select_buf[choose-1][1] );
                    conn2server_port = (unsigned int)atoi( select_buf[choose-1][2] );
                    autosu = atoi(select_buf[choose-1][3]);
                }
                else
                {
                    packet_start( SSH2_MSG_CHANNEL_DATA );
                    packet_put_int( remote_id );
                    snprintf( sel, sizeof(sel), "Invalid Number!\x0d\x0a" );
                    packet_put_string( sel, strlen(sel) );
                    packet_send();
                    packet_write_wait();
                    ret = 1;
                }
            }
        }
    }
    /* SSH1 */
    else
    {
        int choose;
        if ( conn_mode == CONN_MODE_SELECT )
        {
            ret = 1;
            //get_ssh_username_password_from_mysql2( radius_username, server_ip );
            while ( ret )
            {
                packet_start( SSH_SMSG_STDOUT_DATA );
                char sel[1024];
                snprintf( sel, sizeof(sel), "Please choose a username:\x0d\x0a" );
                packet_put_string( sel, strlen(sel) );
                packet_send();
                packet_write_wait();
                for ( i = 0; i < select_cnt; i++ )
                {
                    packet_start( SSH_SMSG_STDOUT_DATA );
                    //char sel[1024];
                    snprintf( sel, sizeof(sel), "[%d]%s\x0d\x0a", i+1, select_buf[i][0] );
                    packet_put_string( sel, strlen(sel) );
                    packet_send();
                    packet_write_wait();
                }
                packet_start( SSH_SMSG_STDOUT_DATA );
                snprintf( sel, sizeof(sel), "[%d]Exit from this system!\x0d\x0aInput: ", select_cnt+1 );
                packet_put_string( sel, strlen(sel) );
                packet_send();
                packet_write_wait();
                choose = process_select_username_input_ssh1( cfd, remote_id );
                if ( choose == select_cnt+1 )
                {
                    fatal( "Exit from radius system.\n");
                }
                else if ( choose > 0 && choose <= select_cnt )
                {
                    strcpy( conn2server_username, select_buf[choose-1][0] );
                    strcpy( conn2server_password, select_buf[choose-1][1] );
                    conn2server_port = (unsigned int)atoi( select_buf[choose-1][2] );
                    autosu = atoi(select_buf[choose-1][3]);
                    ret = 0;
                }
                else
                {
                    packet_start( SSH_SMSG_STDOUT_DATA );
                    snprintf( sel, sizeof(sel), "Invalid Number!\x0d\x0a" );
                    packet_put_string( sel, strlen(sel) );
                    packet_send();
                    packet_write_wait();
                    ret = 1;
                }
            }
        }
    }
    return radius_username;
}


/*
 * Do the FREESVR-SSH-PROXY
 * We fork and let the child connect to the real target
 * and use a socketpair to send the decrypted data to be transfered
 * between the endpoints.
 * ip and port for route in network byte order.
 */

/* Global Var */
MYSQL *sql_conn = NULL;
int   last_insert_id[MAXSESSIONNUM];
int   session_channel_mode[MAXSESSIONNUM];
char  *cstr;
char  *sstr;
/* Global Var */

extern int radius_flag;
extern int original_mode_flag;

void wait_for_target(int cfd, int sp)
{
    struct simple_packet spkt;
    char *pt;

    char target_password[32], *ctrl, status,rflag;
    int char_num = 4, j,len,nfd,ret =1,rchan;
    char delreply1[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x08, 0x1b, 0x5b, 0x4b };
    char delreply2[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07 };
    char ssh1delreply1[] = { 0x00, 0x00, 0x00, 0x04, 0x08, 0x1b, 0x5b, 0x4b };
    char ssh1delreply2[] = { 0x00, 0x00, 0x00, 0x01, 0x07 };
    fd_set readset;
    FD_ZERO(&readset);
    FD_SET(cfd, &readset);
    FD_SET(sp, &readset);
    nfd = (cfd > sp ? cfd : sp) +1;
    memset(&spkt, 0x00, sizeof(spkt));

    while( ret )
    {
        //fd_set readtmp;
        //char spbuf[32];
        //memcpy(&readtmp, &readset, sizeof(readtmp));

        FD_ZERO(&readset);
        FD_SET(cfd, &readset);
        FD_SET(sp, &readset);
        nfd = (cfd > sp ? cfd : sp) +1;

        if ( no_shell )
        {
            FD_ZERO(&readset);
            FD_SET(sp, &readset);
            nfd = sp +1;
        }

        if ( select(nfd, &readset, NULL, NULL, NULL) < 0 )
        {
            if (errno == EINTR)
                continue;
            break;
        }
        if (FD_ISSET(sp, &readset))
        {
            //bzero(spbuf,sizeof(spbuf));
            //if ( (n = readn(sp[0], spbuf, sizeof(spbuf))) <= 0)
            //break;
            readn(sp, &status, 1);
            if ( status == 0x00 )
            {
                if (compat20)
                {
                    packet_start(SSH2_MSG_CHANNEL_DATA);
                    printf("client is putty %d, %d\n",client_is_putty,REMOTEID(0));
                    packet_put_int( REMOTEID(0) );
                    packet_put_cstring( "Target server password error!\x0d\x0aInput target server password: " );
                    packet_send();
                    packet_write_wait();
                }
                else
                {
                    packet_start( SSH_SMSG_STDOUT_DATA );
                    packet_put_cstring("Target server password error!\x0d\x0aInput target server password: ");
                    packet_send();
                    packet_write_wait();
                }
            }
            else
            {
                ret = 0;
            }
        }
        if (FD_ISSET(cfd, &readset))
        {
            while ( (spkt.type = packet_read_next(cfd)) != SSH_MSG_NONE)
            {
                pt = (char *)packet_get_raw((int *)&spkt.len);


                if (process_packet(spkt.type, spkt.data) != 0)
                {
                    memset(&spkt, 0x00, spkt.len+8);
                    continue;
                }

                if (spkt.len > sizeof(spkt.data))
                {
                    fatal("** Darn, buffer to small (%u) for received packet (%u)\n",
                          spkt.len, sizeof(spkt.data));
                }

                //debug("[FREESVR-SSH-PROXY] Got %u bytes from client [type %u]", spkt.len, spkt.type);
                memcpy(spkt.data, pt, spkt.len);

                if ( compat20 )
                {
                    if ( spkt.type == SSH2_MSG_CHANNEL_DATA )
                    {
                        packet_get_int();
                        char *ctrl = packet_get_string(&len);
                        if ( ctrl[0] == 0x0d )
                        {
                            packet_start(SSH2_MSG_CHANNEL_DATA);
                            //if ( remote_id == 256 )
                            //crreply[2] = 0x01;
                            packet_put_int(REMOTEID(0));
                            packet_put_cstring("\x0d\x0a");
                            packet_send();
                            packet_write_wait();
                            target_password[char_num] = '\0';
                            //printf( "target_password = %s\n", target_password+4 );
                            put_u32(target_password,char_num-4);
                            writen(sp,target_password,char_num);
                            char_num = 4;
                        }
                        else if ( ctrl[0] == 0x03 )
                        {
                            char_num = 4;
                            //ret = 0;
                            packet_start(SSH2_MSG_CHANNEL_DATA);
                            //if ( remote_id == 256 )
                            //crreply[2] = 0x01;
                            packet_put_int(REMOTEID(0));
                            packet_put_cstring( "\x0d\x0aInput target server password: ");
                            packet_send();
                            packet_write_wait();
                        }
                        else if ( ctrl[0] == 0x08 || ctrl[0] == 0x7f )
                        {
                            char_num--;
                            //printf("%d\n", remote_id );
                            packet_start(SSH2_MSG_CHANNEL_DATA);
                            if ( client_is_putty )
                            {
                                delreply1[2] = 0x01;
                                delreply2[2] = 0x01;
                            }
                            if ( char_num < 4 )
                            {
                                packet_put_raw( delreply2, sizeof(delreply2) );
                                char_num = 4;
                                //ret = 0;
                            }
                            else
                            {
                                //ret = ret/10;
                                packet_put_raw( delreply1, sizeof(delreply1) );
                            }
                            packet_send();
                            packet_write_wait();
                        }
                        else
                        {
                            for ( j = 0; j < len; j++ )
                            {
                                target_password[char_num++] = ctrl[j];
                                spkt.data[8+j] = '*';
                            }
                            packet_start(SSH2_MSG_CHANNEL_DATA);
                            if ( client_is_putty )
                                spkt.data[2] = 0x01;
                            packet_put_raw(spkt.data, spkt.len);
                            packet_send();
                            packet_write_wait();
                        }
                    }
                    else if ( spkt.type == SSH2_MSG_CHANNEL_OPEN )
                    {
                        packet_get_string(NULL);
                        rchan = packet_get_int();
                        packet_start(SSH2_MSG_CHANNEL_OPEN_FAILURE);
                        packet_put_int(rchan);
                        packet_put_int(1);
                        packet_put_cstring("open failed");
                        packet_put_cstring("");
                        packet_send();
                        packet_write_wait();
                        //memcpy( &mitm_channel_request[mitm_channel_cnt++], &spkt, sizeof( spkt ) );
                    }
                    else if ( spkt.type == SSH2_MSG_CHANNEL_REQUEST )
                    {
                        memcpy( &mitm_channel_request[mitm_channel_cnt++], &spkt, sizeof( spkt ) );
                        packet_get_int();
                        packet_get_string(NULL);
                        rflag = packet_get_char();
                        if ( !rflag )
                        {
                            mitm_channel_reply[mitm_channel_cnt-1] = 0;
                        }
                    }
                    else if ( spkt.type == 20 )
                    {
                        dispatch_run2(DISPATCH_NONBLOCK, NULL, xxx_kex, pt, spkt.len);
                    }
                }
                else
                {
                    if ( spkt.type == SSH_CMSG_STDIN_DATA )
                    {
                        //char_num++;
                        char *ctrl = packet_get_string(&len);
                        if ( ctrl[0] == 0x0d )
                        {
                            packet_start(SSH_SMSG_STDOUT_DATA);
                            packet_put_cstring("\x0d\x0a");
                            packet_send();
                            packet_write_wait();
                            target_password[char_num] = '\0';
                            //printf( "target_password = %s\n", target_password+4 );
                            put_u32(target_password,char_num-4);
                            writen(sp,target_password,char_num);
                            char_num = 4;
                        }
                        else if ( ctrl[0] == 0x03 )
                        {
                            char_num = 4;
                            packet_start(SSH_SMSG_STDOUT_DATA);
                            packet_put_cstring("\x0d\x0aInput target server password: ");
                            packet_send();
                            packet_write_wait();
                        }
                        else if ( ctrl[0] == 0x08 || ctrl[0] == 0x7f )
                        {
                            char_num --;
                            packet_start(SSH_SMSG_STDOUT_DATA);
                            if ( char_num < 4 )
                            {
                                packet_put_raw( ssh1delreply2, sizeof(ssh1delreply2) );
                                char_num = 4;
                            }
                            else
                            {
                                packet_put_raw( ssh1delreply1, sizeof(ssh1delreply1) );
                            }
                            packet_send();
                            packet_write_wait();
                        }
                        else
                        {
                            for ( j = 0; j < len; j++ )
                            {
                                target_password[char_num++] = ctrl[j];
                                spkt.data[4+j] = '*';
                            }
                            packet_start(SSH_SMSG_STDOUT_DATA);
                            packet_put_raw(spkt.data, spkt.len);
                            packet_send();
                            packet_write_wait();
                        }
                    }
                }
                memset(&spkt, 0x00, sizeof(spkt));
            }
        }

    }
    put_u32(target_password,1024);
    writen(sp,target_password,4);
    printf("out of wait!\n");
    return;
}

void
mitm_ssh(int cfd)
{
    int licret = -1;

    /* licenses auth */
    licret = licenses_auth( LICENSES_KEY );
    if ( licret != 0 )
    {
        printf ( "LICENSES KEY AUTH FAILED! ret = %d\n", licret );
        return;
    }
    else printf ( "LICENSES KEY AUTH SUCCESSED!\n" );
    /* licenses auth */

    printf ( "entry proxy main func!\n" );

    size_t  socksize;
	struct sockaddr_in sock1;
	socksize = sizeof(sock1);
	getsockopt(cfd, SOL_IP, SO_ORIGINAL_DST, &sock1, &socksize);
	printf("ori ip = %s, port = %d, %s\n",inet_ntoa(sock1.sin_addr), ntohs(sock1.sin_port), get_local_ipaddr(cfd));

	/* Mysql */
    MYSQL_RES *res_ptr;
    MYSQL_ROW  sqlrow;

    if ( !original_mode_flag )
    {
        sql_conn = mysql_init(NULL);
        sql_conn = mysql_real_connect( sql_conn, mysql_address, mysql_username, mysql_password, mysql_database, 0, NULL, 0 );
        if ( sql_conn )
        {
            printf( "Connect to Mysql success!\n" );
        }
        else
        {
            printf( "Connect to Mysql fail!\n" );
            if ( mysql_errno( sql_conn ) )
            {
                printf( "Mysql Error: %s\n", mysql_error(sql_conn) );
            }
        }
    }
    /* Mysql */

    struct sockaddr_in tgt;
    int sp[2];
    pid_t pid;
    fd_set readset;
    size_t nfd;
    int sock_in, sock_out;
    u_int ssh_proto;
    struct simple_packet spkt;
    ssize_t n;
    int src_data = 0;
    int dst_data = 0;
    FILE *logf = NULL;
    char buf[4096];
    int log_info_response = 0;
    char *info_response_user = NULL;

    /* Add */
    char * radius_username = NULL;
    u_int session_id = 0, channel_req_str_len = 0, exec_command_len = 0, subsystem_name_len = 0;
    u_char channel_req_str[STRLENGTH], exec_command[STRLENGTH], subsystem_name[STRLENGTH];
    int client_first_init_flag[MAXSESSIONNUM], server_first_init_flag[MAXSESSIONNUM];
    int new_client_buffer_flag[MAXSESSIONNUM], new_server_buffer_flag[MAXSESSIONNUM];
    int i = 0, index = 0;
    for ( i = 0; i < MAXSESSIONNUM; i++ )
    {
        client_first_init_flag[i] = 1;
        server_first_init_flag[i] = 1;
        new_client_buffer_flag[i] = 1;
        new_server_buffer_flag[i] = 1;
    }

    Buffer *server_buf[MAXSESSIONNUM], *client_buf[MAXSESSIONNUM];
    memset( server_buf, 0, sizeof(server_buf) );
    memset( client_buf, 0, sizeof(client_buf) );

    u_int  transfer_client_id     [MAXSESSIONNUM], transfer_server_id     [MAXSESSIONNUM];
    u_char command_client_type    [MAXSESSIONNUM], command_server_type    [MAXSESSIONNUM];
    int    copy_client_buffer_size[MAXSESSIONNUM], copy_server_buffer_size[MAXSESSIONNUM];
    int    csp                    [MAXSESSIONNUM], ssp                    [MAXSESSIONNUM];

    int log_download_file_flag[MAXSESSIONNUM], log_download_file_data[MAXSESSIONNUM], sftp_log = 0;
    int log_upload_file_flag[MAXSESSIONNUM], backup_upload_file[MAXSESSIONNUM];
    char backup_download_fn[MAXSESSIONNUM][256], backup_upload_fn[MAXSESSIONNUM][256];
    u_int wr_flag, upload_pflag[MAXSESSIONNUM];
    u_char * data, * filename;
    u_int datalen, filename_len;
    char *user;
    char ssh1_user[256];
    u_int64_t offset;

    queue_clear();
    memset( client_buffer_array,  0, sizeof( client_buffer_array  ) );
    memset( session_channel_mode, 0, sizeof( session_channel_mode ) );
    memset( last_insert_id,       0, sizeof( last_insert_id       ) );
    /* Add */

    sock_in = sock_out = cfd;
    ssh_proto = compat20 ? SSH_PROTO_2 : SSH_PROTO_1;

    signal(SIGCHLD, sighandler);
    signal(SIGUSR1, sighandler);

    /* Add */
    signal(35, sighandler);
    signal(36, sighandler);
    signal(37, sighandler);

    /* Static route */
    memset(&tgt, 0x00, sizeof(tgt));

    /* Get real target or use static route */
    if (get_real_target(cfd, &tgt) != 0)
    {
        tgt.sin_addr.s_addr = mopt.r_addr;
        tgt.sin_port = mopt.r_port;
    }

    if (tgt.sin_addr.s_addr == 0)
        fatal("Failed to get route for client");

    logit("[FREESVR-SSH-PROXY] Routing %s %s:%u -> %s",
          compat20 ? "SSH2" : "SSH1", get_remote_ipaddr(),
          get_remote_port(), net_sockstr(&tgt, 0));

    /* Add radius auth*/
    if ( !original_mode_flag && radius_flag == 1 )
    {
        printf ( "*****Radius auth start!*****\n" );
        radius_username = radius_Authenticate(cfd, tgt.sin_addr.s_addr);
        printf ( "*****Radius auth done!*****\n" );
    }
    /* Add radius auth*/

    if ( device_table_id != -1 )
        get_root_password(conn2server_saddress);
    else
        get_root_password(inet_ntoa(tgt.sin_addr));

    /* Set up the unencrypted data channel to the client */
    if (socketpair(AF_LOCAL, SOCK_STREAM, 0, sp) < 0)
        fatal("socketpair failed: %s", strerror(errno));

    /* Fork off the child that connects to the real target */
    if ( (pid = fork()) < 0)
        fatal("fork: %s\n", strerror(errno));

    if (pid == 0)
    {
        /* Close the unused socket */
        close(sp[0]);
        signal(SIGUSR1, SIG_DFL);

        //target_connect(tgt.sin_addr.s_addr, tgt.sin_port, sp[1], ssh_proto);
        if ( !original_mode_flag && radius_flag == 1 )
        {
            if ( device_table_id != -1 )//method3
            {
                target_connect(inet_addr(conn2server_saddress), htons(conn2server_port), sp[1], ssh_proto);
            }
            else
            {
                target_connect(tgt.sin_addr.s_addr, htons(conn2server_port), sp[1], ssh_proto);
            }
        }
        else
        {
            target_connect(tgt.sin_addr.s_addr, tgt.sin_port, sp[1], ssh_proto);
        }

        /* Unreached */
        exit(EXIT_FAILURE);
    }

    /* Close the unused socket */
    close(sp[1]);

    /* Wait for a signal telling us that the connection
     * is established or terminated. */

    if ( !original_mode_flag && radius_flag == 1 ) wait_for_target(cfd,sp[0]);

    while (target_connected == 0)
        pause();

    //cstr = strdup(net_sockstr_ip(net_inetaddr(get_remote_ipaddr()), htons(get_remote_port()), mopt.resolve));
	cstr = strdup(get_remote_ipaddr());
    sstr = strdup(net_sockstr(&tgt, mopt.resolve));
    if ( device_table_id != -1 ) sstr = conn2server_saddress;

    packet_set_interactive(0);

    if ( !original_mode_flag && compat20 && radius_flag == 1 )
    {
        for ( i = block_channel_cnt; i < mitm_channel_cnt; i++ )
        {
            writen(sp[0], &mitm_channel_request[i], mitm_channel_request[i].len+8);
        }
    }

    /* Do the FREESVR-SSH-PROXY thing */
    FD_ZERO(&readset);
    FD_SET(cfd, &readset);
    FD_SET(sp[0], &readset);

    /* Max file descriptor */
    nfd = (cfd > sp[0] ? cfd : sp[0]) +1;

    /*perl*/
    int fd1[128],fd2[128],fd3[128],waitforline[128];
    char * inputcommandline[128],* commandline[128];
    char * winopenfile[128],* monitor_shell_pipe_name[128];

    memset(&spkt, 0x00, sizeof(spkt));



    if ( !original_mode_flag && radius_flag == 1 )
    {
        if ( compat20 )
        {
            user = conn2server_username;
        }
        else
            strcpy( ssh1_user, conn2server_username );
        for ( index = 0; index < mitm_channel_cnt; index++ )
        {
            if ( compat20 )
            {
                if ( mitm_channel_request[index].len >= 4 )
                {
                    memcpy( &session_id, &mitm_channel_request[index].data[0], 4 );
                    session_id = ntohl( session_id );
                }
                if (mitm_channel_request[index].type == SSH2_MSG_CHANNEL_REQUEST)
                {
                    if ( mitm_channel_request[index].len >= 8 )
                    {
                        memcpy( &channel_req_str_len, &mitm_channel_request[index].data[4], 4 );
                        channel_req_str_len = ntohl( channel_req_str_len );
                        if ( channel_req_str_len <= mitm_channel_request[index].len - 8 && channel_req_str_len < STRLENGTH )
                        {
                            memcpy( channel_req_str, &mitm_channel_request[index].data[8], channel_req_str_len );
                            channel_req_str[channel_req_str_len] = '\0';
                            //printf( "\nCHANNEL REQUEST:%s\n", channel_req_str );
                        }
                    }
                    if ( strcmp(channel_req_str,"shell") == 0 )
                    {
                        //printf("session_id=%d\n",session_id);
                        session_channel_mode[session_id] = SSH_MODE;

                        snprintf(buf, sizeof(buf), "[%s] FREESVR-SSH-PROXY (SSH2) %s -> %s\n"
                                 "SSH2_MSG_CHANNEL_REQUEST: SSH2 CONNECTION, SESSION ID = %d\n",
                                 str_time(time(NULL), NULL), cstr, sstr, session_id);
                        logit("\n%s", buf);

                        /* fork perl ssh2*/
                        char logfilename1[256];
                        char logfilename2[256];
                        char logfilename3[256];
                        inputcommandline[session_id]=malloc(sizeof(char)*10000000);
                        commandline[session_id]=malloc(sizeof(char)*10000000);

                        sprintf(logfilename1,"%s/ssh/pipe_in_logssh=%d.%d",BINPATH,getpid(),session_id);
                        sprintf(logfilename2,"%s/ssh/pipe_command_logssh=%d.%d",BINPATH,getpid(),session_id);
                        sprintf(logfilename3,"%s/ssh/pipe_replay_logssh=%d.%d",BINPATH,getpid(),session_id);

                        winopenfile[session_id]=(char *)malloc(128);
                        sprintf(winopenfile[session_id],"%s/ssh/winopen_logssh=%d.%d",BINPATH,getpid(),session_id);

                        monitor_shell_pipe_name[session_id]=(char *)malloc(128);
                        sprintf(monitor_shell_pipe_name[session_id],"%s/monitor_shell=%d.%d",BINPATH,getpid(),session_id);


                        unlink(logfilename1);
                        unlink(logfilename2);
                        unlink(logfilename3);
                        unlink(winopenfile[session_id]);
                        unlink(monitor_shell_pipe_name[session_id]);


                        if (mkfifo(logfilename1,0777)<0)
                        {
                            printf("mkfifo error :%s\n",logfilename1);
                            // printerror(0,"-ERR","mkfifo error:%s\n",logfilename1);
                        }
                        if (mkfifo(logfilename2,0777)<0)
                        {
                            printf("mkfifo error :%s\n",logfilename2);
                            // printerror(0,"-ERR","mkfifo error:%s\n",logfilename2);
                        }
                        if (mkfifo(logfilename3,0777)<0)
                        {
                            printf("mkfifo error :%s\n",logfilename3);
                            // printerror(0,"-ERR","mkfifo error:%s\n",logfilename3);
                        }

                        char childargv[30];
                        char mainpl[1024];
                        bzero(childargv,30);
                        bzero(mainpl,1024);
                        sprintf(childargv,"logssh=%d.%d",getpid(),session_id);
                        sprintf(mainpl,"%s/bin/freesvr_audit_gateway.pl",BINPATH);
                        if (fork()==0)
                        {
                            if (execlp(mainpl,mainpl,childargv,sstr,cstr,user,radius_username,(char *)0)<0)
                            {
                                printf("perl exec error:%s\n",mainpl);
                                exit(-1);
                            }
                            exit(0);
                        }
                        fd1[session_id]=open(logfilename1,O_WRONLY);
                        fd2[session_id]=open(logfilename2,O_WRONLY);
                        fd3[session_id]=open(logfilename3,O_WRONLY);
                        if (fd1[session_id]<0)
                        {
                            //  printerror(0,"-ERR","logfile open error:%s\n",logfilename1);
                            perror(logfilename1);
                            exit(-1);
                        }
                        if (fd2[session_id]<0)
                        {
                            //  printerror(0,"-ERR","logfile open error:%s\n",logfilename2);
                            perror(logfilename2);
                            exit(-1);
                        }
                        if (fd3[session_id]<0)
                        {
                            //  printerror(0,"-ERR","logfile open error:%s\n",logfilename2);
                            perror(logfilename2);
                            exit(-1);
                        }
                    }
                    else if ( strcmp(channel_req_str,"exec") == 0 )
                    {
                        memcpy( &exec_command_len, &mitm_channel_request[index].data[8+channel_req_str_len+1], 4 );
                        exec_command_len = ntohl( exec_command_len );
                        memcpy( exec_command, &mitm_channel_request[index].data[8+channel_req_str_len+5], exec_command_len );
                        exec_command[exec_command_len] = '\0';
                        //printf( "%s\n", exec_command );
                        if ( exec_command[0] == 's' && exec_command[1] == 'c' && exec_command[2] == 'p' )
                        {
                            session_channel_mode[session_id] == SCP_MODE;
                            snprintf(buf, sizeof(buf), "[%s] FREESVR-SSH-PROXY (SSH2) %s -> %s\n"
                                     "SSH2_MSG_CHANNEL_REQUEST: %s\n",
                                     str_time(time(NULL), NULL), cstr, sstr, exec_command);
                            logit("\n%s", buf);
                        }
                    }
                    else if ( strcmp(channel_req_str,"subsystem") == 0 )//( spkt.data[spkt.len-1] == 'p' )
                    {
                        memcpy( &subsystem_name_len, &mitm_channel_request[index].data[8+channel_req_str_len+1], 4 );
                        subsystem_name_len = ntohl( subsystem_name_len );
                        //if ( subsystem_name_len <= spkt.len - 9 - channel_req_str_len && subsystem_name_len < STRLENGTH )
                        memcpy( subsystem_name, &mitm_channel_request[index].data[8+channel_req_str_len+5], subsystem_name_len );
                        subsystem_name[subsystem_name_len] = '\0';
                        //printf( "%s\n", subsystem_name );

                        if ( strcmp(subsystem_name,"sftp") == 0 )
                        {
                            snprintf(buf, sizeof(buf), "[%s] FREESVR-SSH-PROXY (SSH2) %s -> %s\n"
                                     "SSH2_MSG_CHANNEL_REQUEST: SFTP\n",
                                     str_time(time(NULL), NULL), cstr, sstr);
                            logit("\n%s", buf);

                            session_channel_mode[session_id] = SFTP_MODE;

                            if ( sql_conn )
                            {
                                snprintf( buf, sizeof(buf),
                                          "INSERT INTO sftpsessions(cliaddr,svraddr,audit_addr,radius_user,sftp_user,start) \
										VALUES('%s','%s','%s','%s','%s',now())",
                                          cstr, sstr, audit_address, radius_username, user );
                                /* Insert success */
                                if ( !mysql_query( sql_conn, buf ) )
                                {
                                    if ( !mysql_query( sql_conn, "SELECT LAST_INSERT_ID()") )
                                    {
                                        res_ptr = mysql_use_result(sql_conn);
                                        if ( res_ptr )
                                        {
                                            while ( ( sqlrow = mysql_fetch_row(res_ptr) ) )
                                            {
                                                last_insert_id[session_id] = atoi(sqlrow[0]);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if ( mysql_errno( sql_conn ) )
                                        {
                                            printf( "Mysql Error: %s\n", mysql_error(sql_conn) );
                                        }
                                    }
                                }
                                else
                                {
                                    if ( mysql_errno( sql_conn ) )
                                    {
                                        printf( "Mysql Error: %s\n", mysql_error(sql_conn) );
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                strcpy( ssh1_user, conn2server_username );
                if ( mitm_channel_request[index].type == SSH_CMSG_EXEC_SHELL )
                {
                    //channel_mode = SSH_MODE;
                    session_channel_mode[0] = SSH_MODE;

                    snprintf(buf, sizeof(buf), "[%s] FREESVR-SSH-PROXY (SSH1) %s -> %s\n"
                             "SSH1_CMSG_EXEC_SHELL: SSH1\n",
                             str_time(time(NULL), NULL), cstr, sstr);
                    logit("\n%s", buf);

                    /* fork perl ssh1 */
                    char logfilename1[256];
                    char logfilename2[256];
                    char logfilename3[256];
                    inputcommandline[session_id]=malloc(sizeof(char)*10000000);
                    commandline[session_id]=malloc(sizeof(char)*10000000);

                    sprintf(logfilename1,"%s/ssh/pipe_in_logssh=%d.%d",BINPATH,getpid(),session_id);
                    sprintf(logfilename2,"%s/ssh/pipe_command_logssh=%d.%d",BINPATH,getpid(),session_id);
                    sprintf(logfilename3,"%s/ssh/pipe_replay_logssh=%d.%d",BINPATH,getpid(),session_id);

                    winopenfile[session_id]=(char *)malloc(128);
                    sprintf(winopenfile[session_id],"%s/ssh/winopen_logssh=%d.%d",BINPATH,getpid(),session_id);

                    monitor_shell_pipe_name[session_id]=(char *)malloc(128);
                    sprintf(monitor_shell_pipe_name[session_id],"%s/monitor_shell=%d.%d",BINPATH,getpid(),session_id);


                    unlink(logfilename1);
                    unlink(logfilename2);
                    unlink(logfilename3);
                    unlink(winopenfile[session_id]);
                    unlink(monitor_shell_pipe_name[session_id]);

                    if (mkfifo(logfilename1,0777)<0)
                    {
                        printf("mkfifo error :%s\n",logfilename1);
                        //  printerror(0,"-ERR","mkfifo error:%s\n",logfilename1);
                    }
                    if (mkfifo(logfilename2,0777)<0)
                    {
                        printf("mkfifo error :%s\n",logfilename2);
                        //  printerror(0,"-ERR","mkfifo error:%s\n",logfilename2);
                    }
                    if (mkfifo(logfilename3,0777)<0)
                    {
                        printf("mkfifo error :%s\n",logfilename3);
                        //  printerror(0,"-ERR","mkfifo error:%s\n",logfilename3);
                    }

                    char childargv[30];
                    char mainpl[1024];
                    bzero(childargv,30);
                    bzero(mainpl,1024);
                    sprintf(childargv,"logssh=%d.%d",getpid(),session_id);
                    sprintf(mainpl,"%s/bin/freesvr_audit_gateway.pl",BINPATH);
                    if (fork()==0)
                    {
                        if (execlp(mainpl,mainpl,childargv,sstr,cstr,ssh1_user,radius_username,(char *)0)<0)
                        {
                            printf("perl exec error:%s\n",mainpl);
                            exit(-1);
                        }
                        exit(0);
                    }
                    fd1[session_id]=open(logfilename1,O_WRONLY);
                    fd2[session_id]=open(logfilename2,O_WRONLY);
                    fd3[session_id]=open(logfilename3,O_WRONLY);
                    if (fd1[session_id]<0)
                    {
                        //  printerror(0,"-ERR","logfile open error:%s\n",logfilename1);
                        perror(logfilename1);
                        exit(-1);
                    }
                    if (fd2[session_id]<0)
                    {
                        //  printerror(0,"-ERR","logfile open error:%s\n",logfilename2);
                        perror(logfilename2);
                        exit(-1);
                    }
                    if (fd3[session_id]<0)
                    {
                        //  printerror(0,"-ERR","logfile open error:%s\n",logfilename2);
                        perror(logfilename2);
                        exit(-1);
                    }
                }
                if ( mitm_channel_request[index].type == SSH_CMSG_EXEC_CMD )
                {
                    if ( strcmp(&mitm_channel_request[index].data[4], "/usr/local/libexec/sftp-server") == 0 )
                    {
                        //channel_mode
                        session_channel_mode[0] = SFTP_MODE;

                        if ( sql_conn )
                        {
                            snprintf( buf, sizeof(buf),
                                      "INSERT INTO sftpsessions(cliaddr,svraddr,audit_addr,radius_user,sftp_user,start) \
									VALUES('%s','%s','%s','%s','%s',now())",
                                      cstr, sstr, audit_address, radius_username, ssh1_user );
                            /* Insert success */
                            if ( !mysql_query( sql_conn, buf ) )
                            {
                                if ( !mysql_query( sql_conn, "SELECT LAST_INSERT_ID()") )
                                {
                                    res_ptr = mysql_use_result(sql_conn);
                                    if ( res_ptr )
                                    {
                                        while ( ( sqlrow = mysql_fetch_row(res_ptr) ) )
                                        {
                                            last_insert_id[0] = atoi(sqlrow[0]);
                                        }
                                    }
                                }
                                else
                                {
                                    if ( mysql_errno( sql_conn ) )
                                    {
                                        printf( "Mysql Error: %s\n", mysql_error(sql_conn) );
                                    }
                                }
                            }
                            else
                            {
                                if ( mysql_errno( sql_conn ) )
                                {
                                    printf( "Mysql Error: %s\n", mysql_error(sql_conn) );
                                }
                            }
                        }
                    }
                }
            }

        }
    }

    /* Check alive var */
    int select_ret = -1, check_flag = 0, keepalive_cnt = 0;
    struct timeval check_client_alive_timeout;
    extern int check_client_alive_interval;

    struct simple_packet forward2server_packet, forward2client_packet;
    int forward2server_flag = 0, forward2client_flag = 0;

    if ( check_client_alive_interval == -1 ) check_client_alive_interval = 180;
    printf( "Proxy check client alive interval is %d seconds.\n", check_client_alive_interval );

    for (;;)
    {
        char *pt;

        fd_set readtmp;
        memcpy(&readtmp, &readset, sizeof(readtmp));

        debug("[FREESVR-SSH-PROXY] Selecting on server side %d", getpid());

        if ( check_flag )
        {
            check_client_alive_timeout.tv_sec  = 3;
            check_client_alive_timeout.tv_usec = 0;
        }
        else
        {
            check_client_alive_timeout.tv_sec  = check_client_alive_interval;
            check_client_alive_timeout.tv_usec = 0;
        }

        if ( ( select_ret = select(nfd, &readtmp, NULL, NULL, &check_client_alive_timeout) ) <= 0 )
        {
            if ( select_ret == 0 )
            {
                if ( compat20 )
                {
                    /* Check alive to client */
                    if ( ++keepalive_cnt > 3 )
                        cleanup_exit(255);
                    /* Send check message */
                    packet_start(SSH2_MSG_GLOBAL_REQUEST);
                    packet_put_cstring("keepalive@openssh.com");
                    packet_put_char(1);
                    packet_send();
                    packet_write_wait();

                    check_flag = 1;

                    printf( "Send check alive message to client. @ %s\n", str_time(time(NULL), NULL) );
                    /* Check alive to client */
                }

                continue;
            }
            if (errno == EINTR)
                continue;
            break;
        }

        /* Read from client and write to socketpair */
        /* Log the stream of client */
        if (FD_ISSET(cfd, &readtmp))
        {
            debug("[FREESVR-SSH-PROXY] Reading from client on server side %d", getpid());

            while ( (spkt.type = packet_read_next(cfd)) != SSH_MSG_NONE)
            {
                pt = (char *)packet_get_raw((int *)&spkt.len);

                /* Do not send along packets that only affect us */
                if (process_packet(spkt.type, spkt.data) != 0)
                {
                    memset(&spkt, 0x00, spkt.len+8);
                    continue;
                }

                if (spkt.len > sizeof(spkt.data))
                {
                    fatal("** Darn, buffer to small (%u) for received packet (%u)\n",
                          spkt.len, sizeof(spkt.data));
                }

                debug3("[FREESVR-SSH-PROXY] Got %u bytes from client [type %u]", spkt.len, spkt.type);
                memcpy(spkt.data, pt, spkt.len);

                if ( compat20 )
                {
                    if ( spkt.type == 20 || spkt.type == 30 || spkt.type == 31 || spkt.type == 32 ||
                            spkt.type == 21 || spkt.type == 33 || spkt.type == 34 )
                    {
                        if ( spkt.type == 20 )
                        {
                            dispatch_run2(DISPATCH_NONBLOCK, NULL, xxx_kex, pt, spkt.len);
                        }
                    }
                    /* Check alive */
                    else if ( spkt.type == 82 || spkt.type == 81 )
                    {
                        printf ( "Recv echo from client, keep alive. @ %s\n", str_time(time(NULL), NULL) );
                        keepalive_cnt = 0;
                        check_flag = 0;
                    }
                    else
                    {
                        //if (writen(sp[0], &spkt, spkt.len+8) != spkt.len+8)
                        //break;
                        memset( &forward2server_packet, 0x00,  spkt.len+8 );
                        memcpy( &forward2server_packet, &spkt, spkt.len+8 );
                        forward2server_flag = 1;
                    }
                }
                else
                {
                    //if (writen(sp[0], &spkt, spkt.len+8) != spkt.len+8)
                    //break;
                    memset( &forward2server_packet, 0x00,  spkt.len+8 );
                    memcpy( &forward2server_packet, &spkt, spkt.len+8 );
                    forward2server_flag = 1;
                }

                /* Log SSH2 data */
                if (compat20)
                {
                    if ( spkt.len >= 4 )
                    {
                        memcpy( &session_id, &spkt.data[0], 4 );
                        session_id = ntohl( session_id );
                    }
                    //printf( "Session id = %d\n", session_id );
                    if ( show_stream )
                    {
                        printf("client@%d session=%d type=%d  %d: ", getpid(), session_id, spkt.type, spkt.len);
                        for ( i = 0; i < spkt.len; i++ )
                        {
                            if ( isprint(spkt.data[i]) ) printf ("%c", spkt.data[i] );
                            else
                                printf( " %02x ", (u_char)spkt.data[i] );
                        }
                        printf("\n");
                    }
                    //if ( spkt.type != 94 && spkt.type != 93 )
                    //                    {
                    //                    printf("client type=%d  %d: ",spkt.type, spkt.len);
                    //                    for ( i = 0; i < spkt.len; i++ )
                    //                    {
                    //                        printf( "%02x ", (u_char)spkt.data[i] );
                    //                    }
                    //                    printf("\n");
                    //                    }

                    /* Judge this connection is ssh or scp or sftp */
                    if (spkt.type == SSH2_MSG_CHANNEL_OPEN)
                    {
                        packet_get_string(NULL);
                        if ( packet_get_int() == 256 )
                            client_is_putty = 1;
                    }
                    else if (spkt.type == SSH2_MSG_CHANNEL_REQUEST)
                    {
                        if ( spkt.len >= 8 )
                        {
                            memcpy( &channel_req_str_len, &spkt.data[4], 4 );
                            channel_req_str_len = ntohl( channel_req_str_len );
                            if ( channel_req_str_len <= spkt.len - 8 && channel_req_str_len < STRLENGTH )
                            {
                                memcpy( channel_req_str, &spkt.data[8], channel_req_str_len );
                                channel_req_str[channel_req_str_len] = '\0';
                                printf( "\nCHANNEL REQUEST:%s\n", channel_req_str );
                            }
                        }
                        if ( strcmp(channel_req_str,"shell") == 0 )
                        {
                            session_channel_mode[session_id] = SSH_MODE;

                            snprintf(buf, sizeof(buf), "[%s] FREESVR-SSH-PROXY (SSH2) %s -> %s\n"
                                     "SSH2_MSG_CHANNEL_REQUEST: SSH2 CONNECTION, SESSION ID = %d\n",
                                     str_time(time(NULL), NULL), cstr, sstr, session_id);
                            logit("\n%s", buf);

                            /* fork perl ssh2*/
                            if ( !original_mode_flag )
                            {
                                char logfilename1[256];
                                char logfilename2[256];
                                char logfilename3[256];
                                inputcommandline[session_id]=malloc(sizeof(char)*10000000);
                                commandline[session_id]=malloc(sizeof(char)*10000000);

                                sprintf(logfilename1,"%s/ssh/pipe_in_logssh=%d.%d",BINPATH,getpid(),session_id);
                                sprintf(logfilename2,"%s/ssh/pipe_command_logssh=%d.%d",BINPATH,getpid(),session_id);
                                sprintf(logfilename3,"%s/ssh/pipe_replay_logssh=%d.%d",BINPATH,getpid(),session_id);

                                winopenfile[session_id]=(char *)malloc(128);
                                sprintf(winopenfile[session_id],"%s/ssh/winopen_logssh=%d.%d",BINPATH,getpid(),session_id);

                                monitor_shell_pipe_name[session_id]=(char *)malloc(128);
                                sprintf(monitor_shell_pipe_name[session_id],"%s/monitor_shell=%d.%d",BINPATH,getpid(),session_id);


                                unlink(logfilename1);
                                unlink(logfilename2);
                                unlink(logfilename3);
                                unlink(winopenfile[session_id]);
                                unlink(monitor_shell_pipe_name[session_id]);

                                if (mkfifo(logfilename1,0777)<0)
                                {
                                    printf("mkfifo error :%s\n",logfilename1);
                                    //    printerror(0,"-ERR","mkfifo error:%s\n",logfilename1);
                                }
                                if (mkfifo(logfilename2,0777)<0)
                                {
                                    printf("mkfifo error :%s\n",logfilename2);
                                    //   printerror(0,"-ERR","mkfifo error:%s\n",logfilename2);
                                }
                                if (mkfifo(logfilename3,0777)<0)
                                {
                                    printf("mkfifo error :%s\n",logfilename3);
                                    // printerror(0,"-ERR","mkfifo error:%s\n",logfilename3);
                                }

                                char childargv[30];
                                char mainpl[1024];
                                bzero(childargv,30);
                                bzero(mainpl,1024);
                                sprintf(childargv,"logssh=%d.%d",getpid(),session_id);
                                sprintf(mainpl,"%s/bin/freesvr_audit_gateway.pl",BINPATH);
                                if (fork()==0)
                                {
                                    if (execlp(mainpl,mainpl,childargv,sstr,cstr,user,radius_username,(char *)0)<0)
                                    {
                                        printf("perl exec error:%s\n",mainpl);
                                        exit(-1);
                                    }
                                    exit(0);
                                }
                                fd1[session_id]=open(logfilename1,O_WRONLY);
                                fd2[session_id]=open(logfilename2,O_WRONLY);
                                fd3[session_id]=open(logfilename3,O_WRONLY);
                                if (fd1[session_id]<0)
                                {
                                    //    printerror(0,"-ERR","logfile open error:%s\n",logfilename1);
                                    perror(logfilename1);
                                    exit(-1);
                                }
                                if (fd2[session_id]<0)
                                {
                                    //    printerror(0,"-ERR","logfile open error:%s\n",logfilename2);
                                    perror(logfilename2);
                                    exit(-1);
                                }
                                if (fd3[session_id]<0)
                                {
                                    //    printerror(0,"-ERR","logfile open error:%s\n",logfilename2);
                                    perror(logfilename2);
                                    exit(-1);
                                }
                            }
                        }
                        else if ( strcmp(channel_req_str,"exec") == 0 )
                        {
                            memcpy( &exec_command_len, &spkt.data[8+channel_req_str_len+1], 4 );
                            exec_command_len = ntohl( exec_command_len );
                            memcpy( exec_command, &spkt.data[8+channel_req_str_len+5], exec_command_len );
                            exec_command[exec_command_len] = '\0';
                            printf( "%s\n", exec_command );
                            if ( exec_command[0] == 's' && exec_command[1] == 'c' && exec_command[2] == 'p' )
                            {
                                session_channel_mode[session_id] == SCP_MODE;
                                snprintf(buf, sizeof(buf), "[%s] FREESVR-SSH-PROXY (SSH2) %s -> %s\n"
                                         "SSH2_MSG_CHANNEL_REQUEST: %s\n",
                                         str_time(time(NULL), NULL), cstr, sstr, exec_command);
                                logit("\n%s", buf);
                            }
                        }
                        else if ( strcmp(channel_req_str,"subsystem") == 0 )//( spkt.data[spkt.len-1] == 'p' )
                        {
                            memcpy( &subsystem_name_len, &spkt.data[8+channel_req_str_len+1], 4 );
                            subsystem_name_len = ntohl( subsystem_name_len );
                            //if ( subsystem_name_len <= spkt.len - 9 - channel_req_str_len && subsystem_name_len < STRLENGTH )
                            memcpy( subsystem_name, &spkt.data[8+channel_req_str_len+5], subsystem_name_len );
                            subsystem_name[subsystem_name_len] = '\0';
                            printf( "%s\n", subsystem_name );

                            if ( strcmp(subsystem_name,"sftp") == 0 )
                            {
                                snprintf(buf, sizeof(buf), "[%s] FREESVR-SSH-PROXY (SSH2) %s -> %s\n"
                                         "SSH2_MSG_CHANNEL_REQUEST: SFTP\n",
                                         str_time(time(NULL), NULL), cstr, sstr);
                                logit("\n%s", buf);

                                session_channel_mode[session_id] = SFTP_MODE;

                                if ( sql_conn )
                                {
                                    snprintf( buf, sizeof(buf),
                                              "INSERT INTO sftpsessions(cliaddr,svraddr,audit_addr,radius_user,sftp_user,start) \
											VALUES('%s','%s','%s','%s','%s',now())",
                                              cstr, sstr, audit_address, radius_username, user );
                                    /* Insert success */
                                    if ( !mysql_query( sql_conn, buf ) )
                                    {
                                        if ( !mysql_query( sql_conn, "SELECT LAST_INSERT_ID()") )
                                        {
                                            res_ptr = mysql_use_result(sql_conn);
                                            if ( res_ptr )
                                            {
                                                while ( ( sqlrow = mysql_fetch_row(res_ptr) ) )
                                                {
                                                    last_insert_id[session_id] = atoi(sqlrow[0]);
                                                }
                                            }
                                        }
                                        else
                                        {
                                            if ( mysql_errno( sql_conn ) )
                                            {
                                                printf( "Mysql Error: %s\n", mysql_error(sql_conn) );
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if ( mysql_errno( sql_conn ) )
                                        {
                                            printf( "Mysql Error: %s\n", mysql_error(sql_conn) );
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else if (spkt.type == SSH2_MSG_CHANNEL_CLOSE)
                    {
                        if ( session_channel_mode[session_id] == SSH_MODE )
                        {
                            session_channel_mode[session_id] = 0;
                            snprintf(buf, sizeof(buf), "[%s] FREESVR-SSH-PROXY (SSH2) %s -> %s\n"
                                     "SSH2 EXIT!! SESSION ID = %d\n",
                                     str_time(time(NULL), NULL), cstr, sstr, session_id);
                            logit("\n%s", buf);
                            /* kill perl ssh2*/
                            if ( !original_mode_flag )
                            {
                                close(fd1);
                                close(fd2);
                                close(fd3);
                                free(inputcommandline[session_id]);
                                free(commandline[session_id]);
                            }
                        }
                        if ( session_channel_mode[session_id] == SFTP_MODE )
                        {
                            session_channel_mode[session_id] = 0;
                            if (sql_conn)
                            {
                                snprintf( buf, sizeof(buf),
                                          "UPDATE sftpsessions SET end=now() WHERE sid=%d",
                                          last_insert_id[session_id] );
                                /* Insert success */
                                if ( !mysql_query( sql_conn, buf ) )
                                {
                                    printf("Mysql insert \"update\" command log success!\n" );
                                    last_insert_id[session_id] = 0;
                                }
                                else
                                {
                                    if ( mysql_errno( sql_conn ) )
                                    {
                                        printf( "Mysql Error: %s\n", mysql_error(sql_conn) );
                                    }
                                }
                            }
                        }
                    }
                    else if (spkt.type == SSH2_MSG_USERAUTH_REQUEST)
                    {
                        user = packet_get_string(NULL);
                        char *service = packet_get_string(NULL);
                        char *method = packet_get_string(NULL);

                        debug2("[FREESVR-SSH-PROXY] %s -> %s SSH2_MSG_USERAUTH_REQUEST: %s %s %s",
                               cstr, sstr, user, service, method);

                        if (strcmp(method, "password") == 0)
                        {
                            char c = packet_get_char();
                            char *pass = packet_get_string(NULL);

                            snprintf(buf, sizeof(buf), "[%s] FREESVR-SSH-PROXY (SSH2) %s -> %s\n"
                                     "SSH2_MSG_USERAUTH_REQUEST: %s %s %s %d %s\n",
                                     str_time(time(NULL), NULL), cstr, sstr,
                                     user, service, method, c, pass);
                            logit("\n%s", buf);
                            if (logf != NULL)
                            {
                                fprintf(logf, "%s\n", buf);
                                fflush(logf);
                            }
                        }

                        if (strcmp(method, "keyboard-interactive") == 0)
                        {
                            log_info_response = 1;
                            info_response_user = strdup(user);
                        }
                    }
                    else if (log_info_response && spkt.type == SSH2_MSG_USERAUTH_INFO_RESPONSE)
                    {
                        u_int a = packet_get_int();
                        char *pass = packet_get_string(NULL);

                        snprintf(buf, sizeof(buf), "[%s] FREESVR-SSH-PROXY (SSH2) %s -> %s\n"
                                 "SSH2_MSG_USERAUTH_INFO_RESPONSE: (%s) %s\n",
                                 str_time(time(NULL), NULL), cstr, sstr,
                                 info_response_user, pass);

                        logit("\n%s", buf);
                        if (logf != NULL)
                        {
                            fprintf(logf, "%s\n", buf);
                            fflush(logf);
                        }
                        log_info_response = 0;
                        if (info_response_user)
                        {
                            free(info_response_user);
                            info_response_user = NULL;
                        }
                    }

                    /* Log the stream from client */
                    else if (spkt.type == SSH2_MSG_CHANNEL_DATA)
                    {
                        //                        if ((src_data > 0) && (spkt.len >= 8))
                        //                            writen(src_data, &spkt.data[8], spkt.len-8);

                        if ( session_channel_mode[session_id] == SSH_MODE )
                        {
                            /* write to perl ssh2 client */
                            if ( !original_mode_flag )
                            {
                                char childargv[30];
                                sprintf(childargv,"logssh=%d.%d",getpid(),session_id);
                                //gettimeofday(&ts1, NULL);
                                telnet_writelogfile2(&spkt.data[8],spkt.len-8,monitor_shell_pipe_name[session_id],
                                                     winopenfile[session_id],fd1[session_id],fd2[session_id],
                                                     inputcommandline[session_id],commandline[session_id],&waitforline[session_id]);
                                //gettimeofday(&ts2, NULL);
                            }
                        }

                        if ( session_channel_mode[session_id] == SFTP_MODE )
                        {
                            /* Skip init message */
                            if ( client_first_init_flag[session_id] )
                            {
                                client_first_init_flag[session_id] = 0;
                            }
                            else
                            {
                                /* if buffer is larger than spkt.size */
                                if ( new_client_buffer_flag[session_id] )
                                {
                                    u_int buflen;
                                    copy_client_buffer_size[session_id] = 0;
                                    csp[session_id] = 8;
                                    while ( copy_client_buffer_size[session_id] < spkt.len-8 )
                                    {
                                        memcpy( &buflen, &spkt.data[csp[session_id]], 4 );
                                        buflen = ntohl( buflen );
                                        memcpy( &command_client_type[session_id], &spkt.data[csp[session_id]+4], 1 );
                                        memcpy( &transfer_client_id[session_id], &spkt.data[csp[session_id]+5], 4 );
                                        transfer_client_id[session_id] = ntohl( transfer_client_id[session_id] );

                                        client_buf[session_id]         = (Buffer *)malloc(sizeof(Buffer));
                                        client_buf[session_id]->buf    = (u_char *)malloc(buflen);
                                        client_buf[session_id]->alloc  = buflen;
                                        client_buf[session_id]->offset = 0;
                                        client_buf[session_id]->end = 0;

                                        /* Only a part of a new buffer */
                                        if ( copy_client_buffer_size[session_id] + buflen + 4 > spkt.len-8 )
                                        {
                                            int copy_size = spkt.len-8-copy_client_buffer_size[session_id]-4;
                                            memcpy( client_buf[session_id]->buf, &spkt.data[csp[session_id]+4], copy_size );
                                            client_buf[session_id]->end += copy_size;

                                            copy_client_buffer_size[session_id] += (copy_size+4);

                                            new_client_buffer_flag[session_id] = 0;
                                        }
                                        else
                                        {
                                            memcpy( client_buf[session_id]->buf, &spkt.data[csp[session_id]+4], buflen );
                                            client_buf[session_id]->end += buflen;

                                            copy_client_buffer_size[session_id] += (buflen+4);
                                            csp[session_id] += (buflen+4);

                                            new_client_buffer_flag[session_id] = 1;
                                            /* do */
                                            store_client_buf( session_id, transfer_client_id[session_id], command_client_type[session_id], client_buf[session_id] );
                                        }
                                    }
                                }
                                else
                                {
                                    if ( client_buf[session_id]->end + spkt.len - 8 > client_buf[session_id]->alloc )
                                    {
                                        copy_client_buffer_size[session_id] = client_buf[session_id]->alloc-client_buf[session_id]->end;
                                        csp[session_id] = 8 + client_buf[session_id]->alloc-client_buf[session_id]->end;

                                        memcpy( client_buf[session_id]->buf+client_buf[session_id]->end, &spkt.data[8],
                                                client_buf[session_id]->alloc-client_buf[session_id]->end );
                                        client_buf[session_id]->end = client_buf[session_id]->alloc;

                                        new_client_buffer_flag[session_id] = 1;
                                        /* do */
                                        store_client_buf( session_id, transfer_client_id[session_id], command_client_type[session_id], client_buf[session_id] );

                                        u_int buflen;
                                        while ( copy_client_buffer_size[session_id] < spkt.len-8 )
                                        {
                                            memcpy( &buflen, &spkt.data[csp[session_id]], 4 );
                                            buflen = ntohl( buflen );
                                            memcpy( &command_client_type[session_id], &spkt.data[csp[session_id]+4], 1 );
                                            memcpy( &transfer_client_id[session_id], &spkt.data[csp[session_id]+5], 4 );
                                            transfer_client_id[session_id] = ntohl( transfer_client_id[session_id] );

                                            client_buf[session_id]         = (Buffer *)malloc(sizeof(Buffer));
                                            client_buf[session_id]->buf    = (u_char *)malloc(buflen);
                                            client_buf[session_id]->alloc  = buflen;
                                            client_buf[session_id]->offset = 0;
                                            client_buf[session_id]->end    = 0;

                                            /* Only a part of a new buffer */
                                            if ( copy_client_buffer_size[session_id] + buflen + 4 > spkt.len-8 )
                                            {
                                                int copy_size = spkt.len-8-copy_client_buffer_size[session_id]-4;
                                                memcpy( client_buf[session_id]->buf, &spkt.data[csp[session_id]+4], copy_size );
                                                client_buf[session_id]->end += copy_size;

                                                copy_client_buffer_size[session_id] += (copy_size+4);

                                                new_client_buffer_flag[session_id] = 0;
                                            }
                                            else
                                            {
                                                memcpy( client_buf[session_id]->buf, &spkt.data[csp[session_id]+4], buflen );
                                                client_buf[session_id]->end += buflen;

                                                copy_client_buffer_size[session_id] += (buflen+4);
                                                csp[session_id] += (buflen+4);

                                                new_client_buffer_flag[session_id] = 1;
                                                /* do */
                                                store_client_buf( session_id, transfer_client_id[session_id], command_client_type[session_id], client_buf[session_id] );
                                            }
                                        }

                                    }
                                    else if ( client_buf[session_id]->end + spkt.len - 8 == client_buf[session_id]->alloc )
                                    {
                                        memcpy( client_buf[session_id]->buf+client_buf[session_id]->end, &spkt.data[8], spkt.len-8 );
                                        client_buf[session_id]->end += spkt.len-8;

                                        new_client_buffer_flag[session_id] = 1;
                                        /* do */
                                        store_client_buf( session_id, transfer_client_id[session_id], command_client_type[session_id], client_buf[session_id] );
                                    }
                                    /* client_buf->end + spkt.len - 8 < client_buf->alloc */
                                    else
                                    {
                                        memcpy( client_buf[session_id]->buf+client_buf[session_id]->end, &spkt.data[8], spkt.len-8 );
                                        client_buf[session_id]->end += spkt.len-8;
                                    }
                                }
                            }
                        }
                    }
                }
                /* Log SSH1 data */
                else
                {
                    session_id = 0;

                    if ( show_stream )
                    {
                        printf("SSH1 client@%d type=%d len=%d: ", getpid(), spkt.type, spkt.len );
                        for ( i = 0; i < spkt.len; i++ )
                        {
                            if ( isprint(spkt.data[i]) ) printf("%c", (u_char)spkt.data[i]);
                            else printf( "%02x ", (u_char)spkt.data[i] );
                        }
                        printf("\n");
                    }
                    /* Judge sftp mode */
                    if ( spkt.type == SSH_CMSG_EXEC_SHELL )
                    {
                        //channel_mode = SSH_MODE;
                        session_channel_mode[0] = SSH_MODE;

                        snprintf(buf, sizeof(buf), "[%s] FREESVR-SSH-PROXY (SSH1) %s -> %s\n"
                                 "SSH1_CMSG_EXEC_SHELL: SSH1\n",
                                 str_time(time(NULL), NULL), cstr, sstr);
                        logit("\n%s", buf);

                        /* fork perl ssh1 */
                        if ( !original_mode_flag )
                        {
                            char logfilename1[256];
                            char logfilename2[256];
                            char logfilename3[256];
                            inputcommandline[session_id]=malloc(sizeof(char)*10000000);
                            commandline[session_id]=malloc(sizeof(char)*10000000);

                            sprintf(logfilename1,"%s/ssh/pipe_in_logssh=%d.%d",BINPATH,getpid(),session_id);
                            sprintf(logfilename2,"%s/ssh/pipe_command_logssh=%d.%d",BINPATH,getpid(),session_id);
                            sprintf(logfilename3,"%s/ssh/pipe_replay_logssh=%d.%d",BINPATH,getpid(),session_id);

                            winopenfile[session_id]=(char *)malloc(128);
                            sprintf(winopenfile[session_id],"%s/ssh/winopen_logssh=%d.%d",BINPATH,getpid(),session_id);

                            monitor_shell_pipe_name[session_id]=(char *)malloc(128);
                            sprintf(monitor_shell_pipe_name[session_id],"%s/monitor_shell=%d.%d",BINPATH,getpid(),session_id);


                            unlink(logfilename1);
                            unlink(logfilename2);
                            unlink(logfilename3);
                            unlink(winopenfile[session_id]);
                            unlink(monitor_shell_pipe_name[session_id]);

                            if (mkfifo(logfilename1,0777)<0)
                            {
                                printf("mkfifo error :%s\n",logfilename1);
                                // printerror(0,"-ERR","mkfifo error:%s\n",logfilename1);
                            }
                            if (mkfifo(logfilename2,0777)<0)
                            {
                                printf("mkfifo error :%s\n",logfilename2);
                                // printerror(0,"-ERR","mkfifo error:%s\n",logfilename2);
                            }
                            if (mkfifo(logfilename3,0777)<0)
                            {
                                printf("mkfifo error :%s\n",logfilename3);
                                // printerror(0,"-ERR","mkfifo error:%s\n",logfilename3);
                            }

                            char childargv[30];
                            char mainpl[1024];
                            bzero(childargv,30);
                            bzero(mainpl,1024);
                            sprintf(childargv,"logssh=%d.%d",getpid(),session_id);
                            sprintf(mainpl,"%s/bin/freesvr_audit_gateway.pl",BINPATH);
                            if (fork()==0)
                            {
                                if (execlp(mainpl,mainpl,childargv,sstr,cstr,ssh1_user,radius_username,(char *)0)<0)
                                {
                                    printf("perl exec error:%s\n",mainpl);
                                    exit(-1);
                                }
                                exit(0);
                            }
                            fd1[session_id]=open(logfilename1,O_WRONLY);
                            fd2[session_id]=open(logfilename2,O_WRONLY);
                            fd3[session_id]=open(logfilename3,O_WRONLY);
                            if (fd1[session_id]<0)
                            {
                                //    printerror(0,"-ERR","logfile open error:%s\n",logfilename1);
                                perror(logfilename1);
                                exit(-1);
                            }
                            if (fd2[session_id]<0)
                            {
                                //    printerror(0,"-ERR","logfile open error:%s\n",logfilename2);
                                perror(logfilename2);
                                exit(-1);
                            }
                            if (fd3[session_id]<0)
                            {
                                //    printerror(0,"-ERR","logfile open error:%s\n",logfilename2);
                                perror(logfilename2);
                                exit(-1);
                            }
                        }
                    }
                    if ( spkt.type == SSH_CMSG_EXEC_CMD )
                    {
                        if ( strcmp(&spkt.data[4], "/usr/local/libexec/sftp-server") == 0 )
                        {
                            //channel_mode
                            session_channel_mode[0] = SFTP_MODE;

                            if ( sql_conn )
                            {
                                snprintf( buf, sizeof(buf),
                                          "INSERT INTO sftpsessions(cliaddr,svraddr,audit_addr,radius_user,sftp_user,start) \
										VALUES('%s','%s','%s','%s','%s',now())",
                                          cstr, sstr, audit_address, radius_username, ssh1_user );
                                /* Insert success */
                                if ( !mysql_query( sql_conn, buf ) )
                                {
                                    if ( !mysql_query( sql_conn, "SELECT LAST_INSERT_ID()") )
                                    {
                                        res_ptr = mysql_use_result(sql_conn);
                                        if ( res_ptr )
                                        {
                                            while ( ( sqlrow = mysql_fetch_row(res_ptr) ) )
                                            {
                                                last_insert_id[0] = atoi(sqlrow[0]);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if ( mysql_errno( sql_conn ) )
                                        {
                                            printf( "Mysql Error: %s\n", mysql_error(sql_conn) );
                                        }
                                    }
                                }
                                else
                                {
                                    if ( mysql_errno( sql_conn ) )
                                    {
                                        printf( "Mysql Error: %s\n", mysql_error(sql_conn) );
                                    }
                                }
                            }
                        }
                    }
                    else if (spkt.type == SSH_CMSG_EOF || spkt.type == SSH_CMSG_EXIT_CONFIRMATION)
                    {
                        if ( session_channel_mode[0] == SSH_MODE )
                        {
                            session_channel_mode[0] = 0;
                            snprintf(buf, sizeof(buf), "[%s] FREESVR-SSH-PROXY (SSH1) %s -> %s\n"
                                     "SSH1:Exit!\n",
                                     str_time(time(NULL), NULL), cstr, sstr);
                            logit("\n%s", buf);
                            /* kill perl ssh1 */
                        }
                        if ( session_channel_mode[0] == SFTP_MODE )
                        {
                            session_channel_mode[0] = 0;
                            if (sql_conn)
                            {
                                snprintf( buf, sizeof(buf),
                                          "UPDATE sftpsessions SET end=now() WHERE sid=%d",
                                          last_insert_id[0] );
                                /* Insert success */
                                if ( !mysql_query( sql_conn, buf ) )
                                {
                                    printf("Mysql insert \"update\" command log success!\n" );
                                    last_insert_id[0] = 0;
                                }
                                else
                                {
                                    if ( mysql_errno( sql_conn ) )
                                    {
                                        printf( "Mysql Error: %s\n", mysql_error(sql_conn) );
                                    }
                                }
                            }
                        }
                    }
                    else if ((spkt.type == SSH_CMSG_STDIN_DATA) ||
                             (spkt.type == SSH_SMSG_STDOUT_DATA) ||
                             (spkt.type == SSH_SMSG_STDERR_DATA))
                    {
                        //                        if (src_data > 0)
                        //                            writen(src_data, &spkt.data[4], spkt.len-4);
                        if ( session_channel_mode[0] == SSH_MODE )
                        {
                            /* write to perl ssh1 client */
                            if ( !original_mode_flag )
                            {
                                telnet_writelogfile2(&spkt.data[4],spkt.len-4,monitor_shell_pipe_name[session_id],winopenfile[session_id],
                                                     fd1[session_id],fd2[session_id],inputcommandline[session_id],commandline[session_id],
                                                     &waitforline[session_id]);
                            }
                        }

                        if ( session_channel_mode[0] == SFTP_MODE )
                        {
                            /* Skip init message, SSH1 has two buffers! */
                            if ( client_first_init_flag[0] > -1 )
                            {
                                client_first_init_flag[0] --;
                            }
                            else
                            {
                                /* if buffer is larger than spkt.size */
                                if ( new_client_buffer_flag[0] )
                                {
                                    u_int buflen;
                                    copy_client_buffer_size[0] = 0;
                                    csp[0] = 4;
                                    while ( copy_client_buffer_size[0] < spkt.len-4 )
                                    {
                                        memcpy( &buflen, &spkt.data[csp[0]], 4 );
                                        buflen = ntohl( buflen );
                                        memcpy( &command_client_type[0], &spkt.data[csp[0]+4], 1 );
                                        memcpy( &transfer_client_id[0], &spkt.data[csp[0]+5], 4 );
                                        transfer_client_id[0] = ntohl( transfer_client_id[0] );

                                        client_buf[0]         = (Buffer *)malloc(sizeof(Buffer));
                                        client_buf[0]->buf    = (u_char *)malloc(buflen);
                                        client_buf[0]->alloc  = buflen;
                                        client_buf[0]->offset = 0;
                                        client_buf[0]->end    = 0;

                                        /* Only a part of a new buffer */
                                        if ( copy_client_buffer_size[0] + buflen + 4 > spkt.len-4 )
                                        {
                                            int copy_size = spkt.len-4-copy_client_buffer_size[0]-4;
                                            memcpy( client_buf[0]->buf, &spkt.data[csp[0]+4], copy_size );
                                            client_buf[0]->end += copy_size;

                                            copy_client_buffer_size[0] += (copy_size+4);

                                            new_client_buffer_flag[0] = 0;
                                        }
                                        else
                                        {
                                            memcpy( client_buf[0]->buf, &spkt.data[csp[0]+4], buflen );
                                            client_buf[0]->end += buflen;

                                            copy_client_buffer_size[0] += (buflen+4);
                                            csp[0] += (buflen+4);

                                            new_client_buffer_flag[0] = 1;
                                            /* do */
                                            store_client_buf( 0, transfer_client_id[0], command_client_type[0], client_buf[0] );
                                        }
                                    }
                                }
                                else
                                {
                                    if ( client_buf[0]->end + spkt.len - 4 > client_buf[0]->alloc )
                                    {
                                        copy_client_buffer_size[0] = client_buf[0]->alloc-client_buf[0]->end;
                                        csp[0] = 4 + client_buf[0]->alloc-client_buf[0]->end;

                                        memcpy( client_buf[0]->buf+client_buf[0]->end, &spkt.data[4],
                                                client_buf[0]->alloc-client_buf[0]->end );
                                        client_buf[0]->end = client_buf[0]->alloc;

                                        new_client_buffer_flag[0] = 1;
                                        /* do */
                                        store_client_buf( 0, transfer_client_id[0], command_client_type[0], client_buf[0] );

                                        u_int buflen;
                                        while ( copy_client_buffer_size[0] < spkt.len-4 )
                                        {
                                            memcpy( &buflen, &spkt.data[csp[0]], 4 );
                                            buflen = ntohl( buflen );
                                            memcpy( &command_client_type[0], &spkt.data[csp[0]+4], 1 );
                                            memcpy( &transfer_client_id[0], &spkt.data[csp[0]+5], 4 );
                                            transfer_client_id[0] = ntohl( transfer_client_id[0] );

                                            client_buf[0]         = (Buffer *)malloc(sizeof(Buffer));
                                            client_buf[0]->buf    = (u_char *)malloc(buflen);
                                            client_buf[0]->alloc  = buflen;
                                            client_buf[0]->offset = 0;
                                            client_buf[0]->end    = 0;

                                            /* Only a part of a new buffer */
                                            if ( copy_client_buffer_size[0] + buflen + 4 > spkt.len-4 )
                                            {
                                                int copy_size = spkt.len-4-copy_client_buffer_size[0]-4;
                                                memcpy( client_buf[0]->buf, &spkt.data[csp[0]+4], copy_size );
                                                client_buf[0]->end += copy_size;

                                                copy_client_buffer_size[0] += (copy_size+4);

                                                new_client_buffer_flag[0] = 0;
                                            }
                                            else
                                            {
                                                memcpy( client_buf[0]->buf, &spkt.data[csp[0]+4], buflen );
                                                client_buf[0]->end += buflen;

                                                copy_client_buffer_size[0] += (buflen+4);
                                                csp[0] += (buflen+4);

                                                new_client_buffer_flag[0] = 1;
                                                /* do */
                                                store_client_buf( 0, transfer_client_id[0], command_client_type[0], client_buf[0] );
                                            }
                                        }

                                    }
                                    else if ( client_buf[0]->end + spkt.len - 4 == client_buf[0]->alloc )
                                    {
                                        memcpy( client_buf[0]->buf+client_buf[0]->end, &spkt.data[4], spkt.len-4 );
                                        client_buf[0]->end += spkt.len-4;

                                        new_client_buffer_flag[0] = 1;
                                        /* do */
                                        store_client_buf( 0, transfer_client_id[0], command_client_type[0], client_buf[0] );
                                    }
                                    /* client_buf->end + spkt.len - 8 < client_buf->alloc */
                                    else
                                    {
                                        memcpy( client_buf[0]->buf+client_buf[0]->end, &spkt.data[4], spkt.len-4 );
                                        client_buf[0]->end += spkt.len-4;
                                    }
                                }
                            }
                        }
                    }
                    else if (spkt.type == SSH_CMSG_USER)
                    {
                        memset( ssh1_user, 0, sizeof(ssh1_user) );
                        memcpy( ssh1_user, &spkt.data[4], spkt.len-4 );
                        //printf( "SSH1 USER: %s\n", ssh1_user );
                        snprintf(buf, sizeof(buf), "[%s] FREESVR-SSH-PROXY (SSH1) %s -> %s"
                                 "\nSSH_CMSG_USER: %s\n", str_time(time(NULL), NULL),
                                 cstr, sstr, &spkt.data[4]);
                        logit("\n%s", buf);
                        if (logf != NULL)
                        {
                            fprintf(logf, "%s\n", buf);
                            fflush(logf);
                        }
                    }
                    else if (spkt.type == SSH_CMSG_AUTH_PASSWORD)
                    {
                        snprintf(buf, sizeof(buf), "[%s] FREESVR-SSH-PROXY (SSH1) %s -> %s"
                                 "\nSSH_CMSG_AUTH_PASSWORD: %s\n", str_time(time(NULL),
                                         NULL), cstr, sstr, &spkt.data[4]);
                        logit("\n%s", buf);
                        if (logf != NULL)
                        {
                            fprintf(logf, "%s\n", buf);
                            fflush(logf);
                        }
                    }
                }

                if ( forward2server_flag == 1 )
                {
                    forward2server_flag = 0;
                    if ( block_command_flag == 0 )
                    {
                        if ( writen( sp[0], &forward2server_packet, forward2server_packet.len+8 )
                                != forward2server_packet.len+8 )
                            break;
                    }
                    else
                    {
                        char block_command_fp[64];
                        int sid;
                        bzero(block_command_fp, sizeof(block_command_fp));
                        snprintf(block_command_fp,sizeof(block_command_fp),"/opt/freesvr/audit/gateway/log/ssh/block_%d", getpid());
                        FILE *block_fp = fopen(block_command_fp, "r");
                        if (block_fp) fscanf(block_fp,"%d",&sid);
                        fclose(block_fp);
                        block_command_flag = 0;
                        char block_buf[] =
                        {
                            0x5e, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                            0x03
                        };

                        packet_start(SSH2_MSG_CHANNEL_DATA);
                        if (client_is_putty)
                            packet_put_int(256);
                        else
                        {
                            packet_put_int(sid);
                            put_u32(&block_buf[8], sid);
                        }
                        packet_put_cstring("\x0d\x0a Forbidden command!\x0d\x0a");
                        packet_send();
                        packet_write_wait();

                        if ( writen( sp[0], &block_buf, 17 ) != 17 ) break;
                    }
                }

                memset(&spkt, 0x00, spkt.len+8);
            }
        }

        /* Read from socketpair and write to client */
        /* Log the stream of server */
        if (FD_ISSET(sp[0], &readtmp))
        {

            debug4("[FREESVR-SSH-PROXY] Reading spkt header on server side");
            if ( (n = readn(sp[0], &spkt, 8)) <= 0)
                break;

            if (spkt.len > sizeof(spkt.data))
            {
                fatal("** Darn, buffer to small (%u) for received packet (%u)\n",
                      spkt.len, sizeof(spkt.data));
            }

            debug4("[FREESVR-SSH-PROXY] Reading %u bytes from socketpair on server side", spkt.len);
            if (spkt.len && (n = readn(sp[0], spkt.data, spkt.len)) <= 0)
                break;

            /*debug3("[FREESVR-SSH-PROXY] Got %u bytes from child process", spkt.len);
            packet_start(spkt.type);
            packet_put_raw(spkt.data, spkt.len);
            packet_send();
            packet_write_wait();*/

            memset ( &forward2client_packet, 0x00,  spkt.len+8 );
            memcpy ( &forward2client_packet, &spkt, spkt.len+8 );
            forward2client_flag = 1;

            /* Log SSH2 data
             * TODO: No need to log data that won't appear here */
            if (compat20)
            {
                if ( spkt.len >= 4 )
                {
                    memcpy( &session_id, &spkt.data[0], 4 );
                    session_id = ntohl( session_id );
                }
                if ( session_id == 256 ) session_id = 0;
                //                printf( "Server Session id = %d\n", session_id );
                if ( show_stream )
                {
                    printf("server@%d session=%d type=%d: ", getpid(), session_id, spkt.type);
                    for ( i = 0; i < spkt.len; i++ )
                    {
                        if( isprint(spkt.data[i] ) ) printf("%c",spkt.data[i]);
                        else printf( " %02x ", (unsigned int)spkt.data[i] );
                    }
                    printf("\n");
                }
                //                                for ( i = 8; i < spkt.len; i++ )
                //                                {
                //                                    printf( "%c", (u_char)spkt.data[i] );
                //                                }
                //                                printf("\n");
                //                if ( spkt.type != 94 && spkt.type != 93 )
                //                {
                //                    printf("server type=%d  %d: ",spkt.type, spkt.len);
                //                    for ( i = 0; i < spkt.len; i++ )
                //                    {
                //                        printf( "%02x ", (u_char)spkt.data[i] );
                //                    }
                //                    printf("\n");
                //                }
                if (spkt.type == SSH2_MSG_CHANNEL_CLOSE)
                {
                    if ( session_channel_mode[session_id] == SSH_MODE )
                    {
                        session_channel_mode[session_id] = 0;
                        snprintf(buf, sizeof(buf), "[%s] FREESVR-SSH-PROXY (SSH2) %s -> %s\n"
                                 "SSH2 EXIT!! SESSION ID = %d\n",
                                 str_time(time(NULL), NULL), cstr, sstr, session_id);
                        logit("\n%s", buf);
                        /* kill perl ssh2 */
                        if ( !original_mode_flag )
                        {
                            close(fd1);
                            close(fd2);
                            close(fd3);
                            free(inputcommandline[session_id]);
                            free(commandline[session_id]);
                        }
                    }
                    if ( session_channel_mode[session_id] == SFTP_MODE )
                    {
                        session_channel_mode[session_id] = 0;
                        if (sql_conn)
                        {
                            snprintf( buf, sizeof(buf),
                                      "UPDATE sftpsessions SET end=now() WHERE sid=%d",
                                      last_insert_id[session_id] );
                            /* Insert success */
                            if ( !mysql_query( sql_conn, buf ) )
                            {
                                printf("Mysql insert \"update\" command log success!\n" );
                                last_insert_id[session_id] = 0;
                            }
                            else
                            {
                                if ( mysql_errno( sql_conn ) )
                                {
                                    printf( "Mysql Error: %s\n", mysql_error(sql_conn) );
                                }
                            }
                        }
                    }
                }
                if (spkt.type == SSH2_MSG_USERAUTH_REQUEST)
                {
                    user = packet_get_string(NULL);
                    char *service = packet_get_string(NULL);
                    char *method = packet_get_string(NULL);

                    if (strcmp(method, "password") == 0)
                    {
                        char c = packet_get_char();
                        char *pass = packet_get_string(NULL);

                        snprintf(buf, sizeof(buf), "[%s] FREESVR-SSH-PROXY (SSH2) %s -> %s\n"
                                 "SSH2_MSG_USERAUTH_REQUEST: %s %s %s %d %s\n",
                                 str_time(time(NULL), NULL), cstr, sstr,
                                 user, service, method, c, pass);
                        logit("\n%s", buf);
                        if (logf != NULL)
                        {
                            fprintf(logf, "%s\n", buf);
                            fflush(logf);
                        }
                    }
                }
                else if (spkt.type == SSH2_MSG_CHANNEL_DATA)
                {
                    //                    if ((dst_data > 0) && (spkt.len >= 8))
                    //                        writen(dst_data, &spkt.data[8], spkt.len-8);

                    if ( session_channel_mode[session_id] == SSH_MODE )
                    {
                        /* write to perl ssh2 server */
                        //if ((dst_data > 0) && (spkt.len >= 8))
                        if ( !original_mode_flag )
                        {
                            telnet_writelogfile(&spkt.data[8],spkt.len-8,monitor_shell_pipe_name[session_id],
                                                fd1[session_id],fd2[session_id],fd3[session_id],inputcommandline[session_id],
                                                commandline[session_id],&waitforline[session_id]);
                        }

                    }
                    if ( session_channel_mode[session_id] == SFTP_MODE )
                    {
                        if ( server_first_init_flag[session_id] )
                        {
                            server_first_init_flag[session_id] = 0;
                        }
                        else
                        {
                            /* if buffer is larger than spkt.size */
                            if ( new_server_buffer_flag[session_id] )
                            {
                                u_int buflen;
                                copy_server_buffer_size[session_id] = 0;
                                ssp[session_id] = 8;
                                while ( copy_server_buffer_size[session_id] < spkt.len-8 )
                                {
                                    memcpy( &buflen, &spkt.data[ssp[session_id]], 4 );
                                    buflen = ntohl( buflen );
                                    memcpy( &command_server_type[session_id], &spkt.data[ssp[session_id]+4], 1 );
                                    memcpy( &transfer_server_id[session_id], &spkt.data[ssp[session_id]+5], 4 );
                                    transfer_server_id[session_id] = ntohl( transfer_server_id[session_id] );

                                    server_buf[session_id]         = (Buffer *)malloc(sizeof(Buffer));
                                    server_buf[session_id]->buf    = (u_char *)malloc(buflen);
                                    server_buf[session_id]->alloc  = buflen;
                                    server_buf[session_id]->offset = 0;
                                    server_buf[session_id]->end    = 0;

                                    /* Only a part of a new buffer */
                                    if ( copy_server_buffer_size[session_id] + buflen + 4 > spkt.len-8 )
                                    {
                                        int copy_size = spkt.len-8-copy_server_buffer_size[session_id]-4;
                                        memcpy( server_buf[session_id]->buf, &spkt.data[ssp[session_id]+4], copy_size );
                                        server_buf[session_id]->end += copy_size;

                                        copy_server_buffer_size[session_id] += (copy_size+4);

                                        new_server_buffer_flag[session_id] = 0;
                                    }
                                    else
                                    {
                                        memcpy( server_buf[session_id]->buf, &spkt.data[ssp[session_id]+4], buflen );
                                        server_buf[session_id]->end += buflen;

                                        copy_server_buffer_size[session_id] += (buflen+4);
                                        ssp[session_id] += (buflen+4);

                                        new_server_buffer_flag[session_id] = 1;
                                        /* do */
                                        store_scpair_buf( session_id, transfer_server_id[session_id], command_server_type[session_id], server_buf[session_id] );
                                    }
                                }
                            }
                            else
                            {
                                if ( server_buf[session_id]->end + spkt.len - 8 > server_buf[session_id]->alloc )
                                {
                                    copy_server_buffer_size[session_id] = server_buf[session_id]->alloc-server_buf[session_id]->end;
                                    ssp[session_id] = 8 + server_buf[session_id]->alloc-server_buf[session_id]->end;

                                    memcpy( server_buf[session_id]->buf+server_buf[session_id]->end, &spkt.data[8],
                                            server_buf[session_id]->alloc-server_buf[session_id]->end );
                                    server_buf[session_id]->end = server_buf[session_id]->alloc;

                                    new_server_buffer_flag[session_id] = 1;
                                    /* do */
                                    store_scpair_buf( session_id, transfer_server_id[session_id], command_server_type[session_id], server_buf[session_id] );

                                    u_int buflen;
                                    while ( copy_server_buffer_size[session_id] < spkt.len-8 )
                                    {
                                        memcpy( &buflen, &spkt.data[ssp[session_id]], 4 );
                                        buflen = ntohl( buflen );
                                        memcpy( &command_server_type[session_id], &spkt.data[ssp[session_id]+4], 1 );
                                        memcpy( &transfer_server_id[session_id], &spkt.data[ssp[session_id]+5], 4 );
                                        transfer_server_id[session_id] = ntohl( transfer_server_id[session_id] );

                                        server_buf[session_id]         = (Buffer *)malloc(sizeof(Buffer));
                                        server_buf[session_id]->buf    = (u_char *)malloc(buflen);
                                        server_buf[session_id]->alloc  = buflen;
                                        server_buf[session_id]->offset = 0;
                                        server_buf[session_id]->end    = 0;

                                        /* Only a part of a new buffer */
                                        if ( copy_server_buffer_size[session_id] + buflen + 4 > spkt.len-8 )
                                        {
                                            int copy_size = spkt.len-8-copy_server_buffer_size[session_id]-4;
                                            memcpy( server_buf[session_id]->buf, &spkt.data[ssp[session_id]+4], copy_size );
                                            server_buf[session_id]->end += copy_size;

                                            copy_server_buffer_size[session_id] += (copy_size+4);

                                            new_server_buffer_flag[session_id] = 0;
                                        }
                                        else
                                        {
                                            memcpy( server_buf[session_id]->buf, &spkt.data[ssp[session_id]+4], buflen );
                                            server_buf[session_id]->end += buflen;

                                            copy_server_buffer_size[session_id] += (buflen+4);
                                            ssp[session_id] += (buflen+4);

                                            new_server_buffer_flag[session_id] = 1;
                                            /* do */
                                            store_scpair_buf( session_id, transfer_server_id[session_id], command_server_type[session_id], server_buf[session_id] );
                                        }
                                    }

                                }
                                else if ( server_buf[session_id]->end + spkt.len - 8 == server_buf[session_id]->alloc )
                                {
                                    memcpy( server_buf[session_id]->buf+server_buf[session_id]->end, &spkt.data[8], spkt.len-8 );
                                    server_buf[session_id]->end += spkt.len-8;

                                    new_server_buffer_flag[session_id] = 1;
                                    /* do */
                                    store_scpair_buf( session_id, transfer_server_id[session_id], command_server_type[session_id], server_buf[session_id] );
                                }
                                /* server_buf->end + spkt.len - 8 < server_buf->alloc */
                                else
                                {
                                    memcpy( server_buf[session_id]->buf+server_buf[session_id]->end, &spkt.data[8], spkt.len-8 );
                                    server_buf[session_id]->end += spkt.len-8;
                                }
                            }
                        }
                    }
                }
            }
            /* Log SSH1 data
             * TODO: No need to log data that won't appear here */
            else
            {
                session_id = 0;
                if ( show_stream )
                {
                    printf("SSH1 server@%d type=%d len=%d: ", getpid(), spkt.type, spkt.len );
                    for ( i = 0; i < spkt.len; i++ )
                    {
                        if ( isprint(spkt.data[i]) ) printf("%c",spkt.data[i]);
                        else printf( " %02x ", (u_char)spkt.data[i] );
                    }
                    printf("\n");
                }
                if (spkt.type == SSH_SMSG_EXITSTATUS)
                {
                    if ( session_channel_mode[0] == SSH_MODE )
                    {
                        session_channel_mode[0] = 0;
                        snprintf(buf, sizeof(buf), "[%s] FREESVR-SSH-PROXY (SSH1) %s -> %s\n"
                                 "SSH1:Exit!\n",
                                 str_time(time(NULL), NULL), cstr, sstr);
                        logit("\n%s", buf);
                        /* kill perl ssh1 */
                    }
                    if ( session_channel_mode[0] == SFTP_MODE )
                    {
                        session_channel_mode[0] = 0;
                        if (sql_conn)
                        {
                            snprintf( buf, sizeof(buf),
                                      "UPDATE sftpsessions SET end=now() WHERE sid=%d",
                                      last_insert_id[0] );
                            /* Insert success */
                            if ( !mysql_query( sql_conn, buf ) )
                            {
                                printf("Mysql insert \"update\" command log success!\n" );
                                last_insert_id[0] = 0;
                            }
                            else
                            {
                                if ( mysql_errno( sql_conn ) )
                                {
                                    printf( "Mysql Error: %s\n", mysql_error(sql_conn) );
                                }
                            }
                        }
                    }
                }
                else if ((spkt.type == SSH_CMSG_STDIN_DATA) ||
                         (spkt.type == SSH_SMSG_STDOUT_DATA) ||
                         (spkt.type == SSH_SMSG_STDERR_DATA))
                {
                    //                    if ((dst_data > 0) && (spkt.len >= 4))
                    //                        writen(dst_data, &spkt.data[4], spkt.len-4);

                    if ( session_channel_mode[0] == SSH_MODE )
                    {
                        /* write to perl ssh1 server */
                        if ( !original_mode_flag )
                        {
                            telnet_writelogfile(&spkt.data[4],spkt.len-4,monitor_shell_pipe_name[session_id],
                                                fd1[session_id],fd2[session_id],fd3[session_id],inputcommandline[session_id],
                                                commandline[session_id],&waitforline[session_id]);
                        }

                    }
                    if ( session_channel_mode[0] == SFTP_MODE )
                    {
                        if ( server_first_init_flag[0] )
                        {
                            server_first_init_flag[0] = 0;
                        }
                        else
                        {
                            /* if buffer is larger than spkt.size */
                            if ( new_server_buffer_flag[0] )
                            {
                                u_int buflen;
                                copy_server_buffer_size[0] = 0;
                                ssp[0] = 4;
                                while ( copy_server_buffer_size[0] < spkt.len-4 )
                                {
                                    memcpy( &buflen, &spkt.data[ssp[0]], 4 );
                                    buflen = ntohl( buflen );
                                    memcpy( &command_server_type[0], &spkt.data[ssp[0]+4], 1 );
                                    memcpy( &transfer_server_id[0], &spkt.data[ssp[0]+5], 4 );
                                    transfer_server_id[0] = ntohl( transfer_server_id[0] );

                                    server_buf[0]         = (Buffer *)malloc(sizeof(Buffer));
                                    server_buf[0]->buf    = (u_char *)malloc(buflen);
                                    server_buf[0]->alloc  = buflen;
                                    server_buf[0]->offset = 0;
                                    server_buf[0]->end    = 0;

                                    /* Only a part of a new buffer */
                                    if ( copy_server_buffer_size[0] + buflen + 4 > spkt.len-4 )
                                    {
                                        int copy_size = spkt.len-4-copy_server_buffer_size[0]-4;
                                        memcpy( server_buf[0]->buf, &spkt.data[ssp[0]+4], copy_size );
                                        server_buf[0]->end += copy_size;

                                        copy_server_buffer_size[0] += (copy_size+4);

                                        new_server_buffer_flag[0] = 0;
                                    }
                                    else
                                    {
                                        memcpy( server_buf[0]->buf, &spkt.data[ssp[0]+4], buflen );
                                        server_buf[0]->end += buflen;

                                        copy_server_buffer_size[0] += (buflen+4);
                                        ssp[0] += (buflen+4);

                                        new_server_buffer_flag[0] = 1;
                                        /* do */
                                        store_scpair_buf( 0, transfer_server_id[0], command_server_type[0], server_buf[0] );
                                    }
                                }
                            }
                            else
                            {
                                if ( server_buf[0]->end + spkt.len - 4 > server_buf[0]->alloc )
                                {
                                    copy_server_buffer_size[0] = server_buf[0]->alloc-server_buf[0]->end;
                                    ssp[0] = 4 + server_buf[0]->alloc-server_buf[0]->end;

                                    memcpy( server_buf[0]->buf+server_buf[0]->end, &spkt.data[4],
                                            server_buf[0]->alloc-server_buf[0]->end );
                                    server_buf[0]->end = server_buf[0]->alloc;

                                    new_server_buffer_flag[0] = 1;
                                    /* do */
                                    store_scpair_buf( 0, transfer_server_id[0], command_server_type[0], server_buf[0] );

                                    u_int buflen;
                                    while ( copy_server_buffer_size[0] < spkt.len-4 )
                                    {
                                        memcpy( &buflen, &spkt.data[ssp[0]], 4 );
                                        buflen = ntohl( buflen );
                                        memcpy( &command_server_type[0], &spkt.data[ssp[0]+4], 1 );
                                        memcpy( &transfer_server_id[0], &spkt.data[ssp[0]+5], 4 );
                                        transfer_server_id[0] = ntohl( transfer_server_id[0] );

                                        server_buf[0]         = (Buffer *)malloc(sizeof(Buffer));
                                        server_buf[0]->buf    = (u_char *)malloc(buflen);
                                        server_buf[0]->alloc  = buflen;
                                        server_buf[0]->offset = 0;
                                        server_buf[0]->end    = 0;

                                        /* Only a part of a new buffer */
                                        if ( copy_server_buffer_size[0] + buflen + 4 > spkt.len-4 )
                                        {
                                            int copy_size = spkt.len-4-copy_server_buffer_size[0]-4;
                                            memcpy( server_buf[0]->buf, &spkt.data[ssp[0]+4], copy_size );
                                            server_buf[0]->end += copy_size;

                                            copy_server_buffer_size[0] += (copy_size+4);

                                            new_server_buffer_flag[0] = 0;
                                        }
                                        else
                                        {
                                            memcpy( server_buf[0]->buf, &spkt.data[ssp[0]+4], buflen );
                                            server_buf[0]->end += buflen;

                                            copy_server_buffer_size[0] += (buflen+4);
                                            ssp[0] += (buflen+4);

                                            new_server_buffer_flag[0] = 1;
                                            /* do */
                                            store_scpair_buf( 0, transfer_server_id[0], command_server_type[0], server_buf[0] );
                                        }
                                    }

                                }
                                else if ( server_buf[0]->end + spkt.len - 4 == server_buf[0]->alloc )
                                {
                                    memcpy( server_buf[0]->buf+server_buf[0]->end, &spkt.data[4], spkt.len-4 );
                                    server_buf[0]->end += spkt.len-4;

                                    new_server_buffer_flag[0] = 1;
                                    /* do */
                                    store_scpair_buf( 0, transfer_server_id[0], command_server_type[0], server_buf[0] );
                                }
                                /* server_buf->end + spkt.len - 8 < server_buf->alloc */
                                else
                                {
                                    memcpy( server_buf[0]->buf+server_buf[0]->end, &spkt.data[4], spkt.len-4 );
                                    server_buf[0]->end += spkt.len-4;
                                }
                            }
                        }
                    }
                }
                else if (spkt.type == SSH_CMSG_USER)
                {
                    snprintf(buf, sizeof(buf), "[%s] FREESVR-SSH-PROXY (SSH1) %s -> %s"
                             "\nSSH_CMSG_USER: %s", str_time(time(NULL), NULL),
                             sstr, cstr, &spkt.data[4]);
                    logit("%s", buf);
                    if (logf)
                    {
                        fprintf(logf, "%s\n\n", buf);
                        fflush(logf);
                    }
                }
                else if (spkt.type == SSH_CMSG_AUTH_PASSWORD)
                {
                    snprintf(buf, sizeof(buf), "[%s] FREESVR-SSH-PROXY (SSH1) %s -> %s"
                             "\nSSH_CMSG_AUTH_PASSWORD: %s", str_time(time(NULL), NULL),
                             sstr, cstr, &spkt.data[4]);
                    logit("%s", buf);
                    if (logf)
                    {
                        fprintf(logf, "%s\n\n", buf);
                        fflush(logf);
                    }
                }
            }

            if ( forward2client_flag == 1 )
            {
                forward2client_flag = 0;
                packet_start(forward2client_packet.type);
                packet_put_raw(forward2client_packet.data, forward2client_packet.len);
                packet_send();
                packet_write_wait();
            }

            memset(&spkt, 0x00, spkt.len+8);
        }
        while ( queue_size() > 0 )
        {
            int index = queue_top();
            u_int ctype, stype, sid;
            Buffer * cbuf, * sbuf;

            sid   = transfer_queue[index].session_id;
            ctype = transfer_queue[index].client_command_type;
            stype = transfer_queue[index].server_command_type;
            cbuf  = transfer_queue[index].client_queue_buf;
            sbuf  = transfer_queue[index].server_queue_buf;

            printf( "SID:%d, ID:%d   ", transfer_queue[index].session_id, transfer_queue[index].transfer_id );
            printf( "ctype %d   ",	  transfer_queue[index].client_command_type );
            printf( "stype %d \n", 	  transfer_queue[index].server_command_type );

            /* Download or upload file */
            if ( ctype == SSH2_FXP_OPEN && stype == SSH2_FXP_HANDLE )
            {
                /* Skip type and id */
                buffer_get_char(cbuf);
                buffer_get_int(cbuf);

                /* Get filename */
                filename = buffer_get_string(cbuf, &filename_len);

                /* Get flag */
                wr_flag = buffer_get_int(cbuf);
                int tmp_wr_flag = wr_flag;
                tmp_wr_flag &= ~0xfffffffd;

                //printf("wr_flag = %d\n",wr_flag);

                if ( tmp_wr_flag )
                {
                    log_upload_file_flag[sid] = 1;

                    /* Get pflag for sftp put command */
                    upload_pflag[sid] = buffer_get_int(cbuf);

                    /* No pflag */
                    if ( upload_pflag[sid] == 0x00000004 )
                    {
                        upload_pflag[sid] = 0;
                    }
                    /* Have pflag */
                    else if ( upload_pflag[sid] == 0x0000000c )
                    {
                        upload_pflag[sid] = 1;
                    }
                    /* Unknow */
                    else upload_pflag[sid] = 2;

                    /* Creat backup fd of upload file */
                    /*snprintf(buf, sizeof(buf), "%s/backup_put_file/%s %s -> %s [%s]", options.c_logdir,
                      modify_filename(filename,filename_len), cstr, sstr, str_time(time(NULL), NULL) );*/
                    snprintf ( buf, sizeof(buf), "/opt/freesvr/audit/log/sftp/upload/%s[%s]",
                               modify_filename(filename,filename_len), str_time(time(NULL), NULL) );
                    //memset ( backup_upload_fn[sid], 0x00, sizeof(backup_upload_fn[sid]) );
                    strcpy ( backup_upload_fn[sid], buf );
                    if ( (backup_upload_file[sid] = open(buf, O_RDWR|O_APPEND|O_CREAT, 0777)) < 0 )
                        error("Failed to open log_download_file_data: '%s'", buf);
                }
                else if ( wr_flag == 0x00000001 )
                {
                    log_download_file_flag[sid] = 1;

                    /* Creat backup fd of download file */
                    /*snprintf(buf, sizeof(buf), "%s/backup_get_file/%s %s <- %s [%s]", options.c_logdir,
                      modify_filename(filename,filename_len), cstr, sstr, str_time(time(NULL), NULL) );*/
                    snprintf ( buf, sizeof(buf), "/opt/freesvr/audit/log/sftp/download/%s[%s]",
                               modify_filename(filename,filename_len), str_time(time(NULL), NULL) );
                    //printf("%s\n",buf);
                    strcpy ( backup_download_fn[sid], buf );
                    if ( (log_download_file_data[sid] = open(buf, O_RDWR|O_APPEND|O_CREAT, 0777)) < 0 )
                        error("Failed to open log_download_file_data: '%s'", buf);
                }
            }
            if ( ctype == SSH2_FXP_READ && stype == SSH2_FXP_DATA
                    && log_download_file_flag[sid] && log_download_file_data[sid] > 0 )
            {
                /* Skip server type and id */
                buffer_get_char(sbuf);
                buffer_get_int(sbuf);

                data = buffer_get_string(sbuf, &datalen);

                /* Skip client type and id */
                buffer_get_char(cbuf);
                buffer_get_int(cbuf);

                /* Skip handle */
                buffer_get_string(cbuf, NULL);

                /* Get offset of file */
                offset = buffer_get_int64(cbuf);

                if ( lseek( log_download_file_data[sid], offset, SEEK_SET ) != -1 )
                    write( log_download_file_data[sid], data, datalen );
            }
            if (  ( ctype == SSH2_FXP_READ || ctype == SSH2_FXP_CLOSE ) && stype == SSH2_FXP_STATUS && log_download_file_flag[sid] )
            {
                /* Skip type and id */
                buffer_get_char(sbuf);
                buffer_get_int(sbuf);

                /* Get status in server buffer */
                u_int server_status = buffer_get_int(sbuf);

                //printf( "server_status = %d\n", server_status );
                /* Download success, close fd and modify the flag */
                if ( server_status == SSH2_FX_EOF || server_status == SSH2_FX_OK )
                {
                    log_download_file_flag[sid] = 0;
                    close(log_download_file_data[sid]);

                    snprintf(buf, sizeof(buf), "[%s] get %s %s <- %s\n",
                             str_time(time(NULL), NULL), filename, cstr, sstr );
                    write( sftp_log, buf, strlen(buf) );

                    if ( sql_conn )
                    {
                        snprintf( buf, sizeof(buf),
                                  "INSERT INTO sftpcomm(sid,comm,at,filename) VALUES(%d,'%s %s',now(),'%s')",
                                  last_insert_id[sid], "get", filename, backup_download_fn[sid] );
                        /* Insert success */
                        if ( !mysql_query( sql_conn, buf ) )
                        {
                            printf("SID = %d, Mysql insert \"get\" command log success!\n", sid );
                        }
                        else
                        {
                            if ( mysql_errno( sql_conn ) )
                            {
                                printf( "Mysql Error: %s\n", mysql_error(sql_conn) );
                            }
                        }
                    }
                }
                else
                {
                    //error
                }
            }
            if ( ctype == SSH2_FXP_WRITE && stype == SSH2_FXP_STATUS
                    && log_upload_file_flag[sid] && backup_upload_file[sid] > 0 )
            {
                /* Skip type and id */
                buffer_get_char(cbuf);
                buffer_get_int(cbuf);

                /* Skip handle and offset */
                buffer_get_string(cbuf, NULL);
                offset = buffer_get_int64(cbuf);

                /* Skip type and id */
                buffer_get_char(sbuf);
                buffer_get_int(sbuf);

                /* Get status in server buffer */
                u_int server_status = buffer_get_int(sbuf);

                /* Write success, log it */
                if ( server_status == SSH2_FX_OK )
                {
                    data = buffer_get_string(cbuf, &datalen);
                    if ( lseek( backup_upload_file[sid], offset, SEEK_SET ) != -1 )
                        write( backup_upload_file[sid], data, datalen );
                }
                else
                {
                    log_upload_file_flag[sid] = 0;
                    close(backup_upload_file[sid]);
                }
            }
            if ( ctype == SSH2_FXP_CLOSE && stype == SSH2_FXP_STATUS && log_upload_file_flag[sid] )
            {
                /* Skip type and id */
                buffer_get_char(sbuf);
                buffer_get_int(sbuf);

                /* Get status in server buffer */
                u_int server_status = buffer_get_int(sbuf);

                /* upload success, close fd and modify the flag */
                if ( server_status == SSH2_FX_OK )
                {
                    log_upload_file_flag[sid] = 0;
                    close(backup_upload_file[sid]);
                    snprintf(buf, sizeof(buf), "[%s] put%s %s %s -> %s\n",
                             str_time(time(NULL), NULL), (upload_pflag==1) ? " -p" : "", filename, cstr, sstr );
                    write( sftp_log, buf, strlen(buf) );

                    if ( sql_conn )
                    {
                        snprintf( buf, sizeof(buf),
                                  "INSERT INTO sftpcomm(sid,comm,at,filename) VALUES(%d,'%s%s %s',now(),'%s')",
                                  last_insert_id[sid], "put", (upload_pflag==1) ? " -p" : "", filename, backup_upload_fn[sid] );
                        /* Insert success */
                        if ( !mysql_query( sql_conn, buf ) )
                        {
                            printf("SID = %d, Mysql insert \"put\" command log success!\n", sid );
                        }
                        else
                        {
                            if ( mysql_errno( sql_conn ) )
                            {
                                printf( "Mysql Error: %s\n", mysql_error(sql_conn) );
                            }
                        }
                    }
                }
                else
                {
                    //error
                }
            }
            /* Process rename command */
            if ( (ctype == SSH2_FXP_RENAME || ctype == SSH2_FXP_EXTENDED) && stype == SSH2_FXP_STATUS )
            {
                /* Skip type and id */
                buffer_get_char(sbuf);
                buffer_get_int(sbuf);

                /* Get status in server buffer */
                u_int server_status = buffer_get_int(sbuf);

                if ( server_status == SSH2_FX_OK )
                {
                    /* Skip type and id */
                    buffer_get_char(cbuf);
                    buffer_get_int(cbuf);

                    /* Skip "posix-rename@openssh.com" */
                    if ( ctype == SSH2_FXP_EXTENDED )
                    {
                        buffer_get_string(cbuf, NULL);
                    }

                    char * oldpath = buffer_get_string(cbuf, NULL);
                    char * newpath = buffer_get_string(cbuf, NULL);

                    snprintf(buf, sizeof(buf), "[%s] rename %s %s %s <- %s\n",
                             str_time(time(NULL), NULL), oldpath, newpath, cstr, sstr );
                    write( sftp_log, buf, strlen(buf) );

                    if ( sql_conn )
                    {
                        snprintf( buf, sizeof(buf),
                                  "INSERT INTO sftpcomm(sid,comm,at) VALUES(%d,'%s %s %s',now())",
                                  last_insert_id[sid], "rename", oldpath, newpath );
                        /* Insert success */
                        if ( !mysql_query( sql_conn, buf ) )
                        {
                            printf("Mysql insert \"rename\" command log success!\n" );
                        }
                        else
                        {
                            if ( mysql_errno( sql_conn ) )
                            {
                                printf( "Mysql Error: %s\n", mysql_error(sql_conn) );
                            }
                        }
                    }
                }
            }
            queue_pop();
        }
    }//end for(;;)

    /* If the spoofed client decided to shut down the connection, this is
     * a great place for hijacking :-) */
    if (errno && n)
        logit("** Error: %s\n", strerror(errno));

    packet_close();
    kill(SIGTERM, pid);
    wait(NULL);

    if (src_data > 0)
        close(src_data);
    if (dst_data > 0)
        close(dst_data);
    if (sftp_log > 0)
        close(sftp_log);
    if (logf)
        fclose(logf);
    if (log_download_file_data > 0)
        close(log_download_file_data);
    if (backup_upload_file > 0)
        close(backup_upload_file);

    exit(errno ? EXIT_FAILURE : EXIT_SUCCESS);
}

struct simple_packet data_cpy[64];
int data_cnt = 0;
struct simple_packet aareq_cpy[64];
int aareq_cnt = 0;

uid_t original_real_uid;
uid_t original_effective_uid;
pid_t proxy_command_pid;
Options client_options;

extern int supported_authentications;

int target_auth( int sock, int sp )
{
    printf("target_auth!\n");
    char * pt;
    int i, ret = 1, index, remote_id, size, num_prompts;
    int userauth_failure_cnt = 0, challenge_failure_cnt = 0, is_challenge = 1, passwd_len;
    struct simple_packet spkt;
    struct timeval timeout;
    char * padded, target_password[32], status;

    /* Creat SSH2 Request and Password string */
    if ( compat20 )
    {
        packet_start(SSH2_MSG_SERVICE_REQUEST);
        packet_put_cstring("ssh-userauth");
        packet_send();
        packet_write_wait();
    }
    /* Creat SSH1 Request and Password string */
    else
    {
        packet_start(SSH_CMSG_USER);
        packet_put_cstring(conn2server_username);
        packet_send();
        packet_write_wait();
    }

    fd_set readset;
    FD_ZERO(&readset);
    FD_SET(sock, &readset);
    FD_SET(sp,   &readset);
    memset(&spkt, 0x00, sizeof(spkt));
    while ( ret )
    {
        fd_set readtmp;
        memcpy(&readtmp, &readset, sizeof(readtmp));

        if (select((sock>sp?sock:sp)+1, &readtmp, NULL, NULL, NULL) < 0)
        {
            if (errno == EINTR)
                continue;
            break;
        }

        if (FD_ISSET(sock, &readtmp))
        {

            debug4("[FREESVR-SSH-PROXY] Reading from client on client side");
            while ( (spkt.type = packet_read_next(sock)) != SSH_MSG_NONE)
            {
                pt = packet_get_raw(&spkt.len);

                /* Do not send along packets that only affect us */
                if (process_packet(spkt.type, spkt.data) != 0)
                {
                    memset(&spkt, 0x00, spkt.len+8);
                    continue;
                }

                if (spkt.len > sizeof(spkt.data))
                {
                    fatal("** Darn, buffer to small (%u) for received packet (%u)\n",
                          spkt.len, sizeof(spkt.data));
                }

                memcpy(spkt.data, pt, spkt.len);
                debug("[FREESVR-SSH-PROXY] Got %u bytes from target [type %u]", spkt.len, spkt.type);

                if ( compat20 )
                {
                    if ( spkt.type == SSH2_MSG_SERVICE_ACCEPT )
                    {
                        packet_start(SSH2_MSG_USERAUTH_REQUEST);
                        packet_put_cstring(conn2server_username);
                        packet_put_cstring("ssh-connection");
                        packet_put_cstring("none");
                        packet_send();
                        packet_write_wait();
                    }
                    else if ( spkt.type == SSH2_MSG_USERAUTH_FAILURE )
                    {
                        userauth_failure_cnt++;
                        if ( userauth_failure_cnt == 1 )
                        {
                            packet_start(SSH2_MSG_USERAUTH_REQUEST);
                            packet_put_cstring(conn2server_username);
                            packet_put_cstring("ssh-connection");
                            packet_put_cstring("keyboard-interactive");
                            packet_put_cstring("");
                            packet_put_cstring("");
                            packet_send();
                            packet_write_wait();
                        }
                        else if ( is_challenge == 1 && userauth_failure_cnt == 2 )
                        {
                            packet_start(SSH2_MSG_USERAUTH_REQUEST);
                            packet_put_cstring(conn2server_username);
                            packet_put_cstring("ssh-connection");
                            packet_put_cstring("password");
                            packet_put_char(0);
                            packet_put_cstring(conn2server_password);
                            packet_send();
                            packet_write_wait();
                        }
                        else
                        {
                            //char tmpbuf[] = "password error!";
                            //printf("size: %d\n", sizeof(tmpbuf) );
                            status = 0x00;
                            writen(sp, &status, 1);
                            printf("PASSWORD ERROR\n");
                        }
                    }
                    else if ( spkt.type == SSH2_MSG_USERAUTH_INFO_REQUEST )
                    {
                        is_challenge = 1024;
                        packet_get_string(NULL);
                        packet_get_string(NULL);
                        packet_get_string(NULL);
                        num_prompts = packet_get_int();
                        if ( num_prompts > 1 )
                        {
                            /* debug */
                        }
                        packet_start(SSH2_MSG_USERAUTH_INFO_RESPONSE);
                        packet_put_int(num_prompts);
                        for (i = 0; i < num_prompts; i++)
                        {
                            packet_get_string(NULL);
                            packet_get_char();
                            packet_put_cstring(conn2server_password);
                        }
                        packet_send();
                        packet_write_wait();
                    }
                    else if ( spkt.type == SSH2_MSG_USERAUTH_SUCCESS )
                    {
                        //ret = 0;
                        status = 0x01;
                        writen(sp,&status,1);
                    }
                }

                else
                {
                    if( is_challenge && spkt.type == SSH_SMSG_FAILURE )
                    {
                        is_challenge --;
                        challenge_failure_cnt++;
                        /*if ((supported_authentications & (1 << SSH_AUTH_TIS)) &&
                             client_options.challenge_response_authentication &&
                             !client_options.batch_mode)*/
                        if ( challenge_failure_cnt == 1 )
                        {
                            packet_start(SSH_CMSG_AUTH_TIS);
                            packet_send();
                            packet_write_wait();
                        }
                        else
                        {
                            status = 0x00;
                            writen(sp, &status, 1);
                            printf("Password error!\n");
                        }
                        /*if ((supported_authentications & (1 << SSH_AUTH_PASSWORD)) &&
                             client_options.password_authentication &&
                             !client_options.batch_mode)
                             {
                                 packet_start(SSH_CMSG_AUTH_PASSWORD);
                                 packet_put_cstring(conn2server_password);
                                 packet_send();
                                 packet_write_wait();
                             }*/
                    }
                    else if ( !is_challenge && spkt.type == SSH_SMSG_FAILURE )
                    {
                        /* Password auth */
                        userauth_failure_cnt++;
                        if ( userauth_failure_cnt == 1 )
                        {
                            packet_start(SSH_CMSG_AUTH_PASSWORD);
                            packet_put_cstring(conn2server_password);
                            packet_send();
                            packet_write_wait();
                        }
                        else
                        {
                            status = 0x00;
                            writen(sp, &status, 1);
                            printf("Password error!\n");
                        }
                    }
                    else if ( spkt.type == SSH_SMSG_SUCCESS )
                    {
                        status = 0x01;
                        writen(sp,&status,1);
                    }
                    else if ( spkt.type == SSH_SMSG_AUTH_TIS_CHALLENGE )
                    {
                        is_challenge = 1024;
                        packet_start(SSH_CMSG_AUTH_TIS_RESPONSE);
                        size = roundup(strlen(conn2server_password) + 1, 32);
                        padded = xcalloc(1, size);
                        strlcpy(padded, conn2server_password, size);
                        packet_put_string(padded, size);
                        printf("size = %d\n", size);
                        memset(padded, 0, size);
                        xfree(padded);
                        packet_send();
                        packet_write_wait();
                    }
                }
                memset(&spkt, 0x00, spkt.len+8);
            }
        }
        if (FD_ISSET(sp, &readtmp))
        {
            bzero(target_password,sizeof(target_password));
            //printf("recv\n");
            readn(sp, target_password, 4);
            //printf("recv\n");
            passwd_len = get_u32(target_password);
            if ( passwd_len == 1024 )
            {
                ret = 0;
            }
            else
            {
                readn(sp,target_password+4,passwd_len);
                //printf("%d %s\n", passwd_len, target_password+4);

                if ( compat20 )
                {
                    if ( is_challenge == 1 )
                    {
                        packet_start(SSH2_MSG_USERAUTH_REQUEST);
                        packet_put_cstring(conn2server_username);
                        packet_put_cstring("ssh-connection");
                        packet_put_cstring("password");
                        packet_put_char(0);
                        packet_put_cstring(target_password+4);
                        packet_send();
                        packet_write_wait();
                    }
                    else
                    {
                        strcpy(conn2server_password,target_password+4);
                        packet_start(SSH2_MSG_USERAUTH_REQUEST);
                        packet_put_cstring(conn2server_username);
                        packet_put_cstring("ssh-connection");
                        packet_put_cstring("keyboard-interactive");
                        packet_put_cstring("");
                        packet_put_cstring("");
                        packet_send();
                        packet_write_wait();
                    }
                }
                else//ssh1
                {
                    if ( is_challenge > 0 )
                    {
                        /*packet_start(SSH_CMSG_AUTH_TIS_RESPONSE);
                        size = roundup(strlen(target_password+4) + 1, 32);
                        padded = xcalloc(1, size);
                        strlcpy(padded, target_password+4, size);
                        packet_put_string(padded, size);
                        printf("size = %d\n", size);
                        memset(padded, 0, size);
                        xfree(padded);
                        packet_send();
                        packet_write_wait();*/
                        strcpy(conn2server_password,target_password+4);
                        packet_start(SSH_CMSG_AUTH_TIS);
                        packet_send();
                        packet_write_wait();
                    }
                    else
                    {
                        packet_start(SSH_CMSG_AUTH_PASSWORD);
                        packet_put_cstring(target_password+4);
                        packet_send();
                        packet_write_wait();
                    }
                }
            }
        }
    }

    if ( compat20 )
    {
        for ( index = 0; index < mitm_channel_cnt; index++ )
        {
            int j;
            printf ( "lianjie : spkt.type = %d, spkt.len = %d\n", mitm_channel_request[index].type, mitm_channel_request[index].len );

                        for ( j = 0; j < mitm_channel_request[index].len; j++ )
                        {
                            if ( isprint(mitm_channel_request[index].data[j]) ) printf("%c",mitm_channel_request[index].data[j]);
                            else printf( "%02x ", (u_char)mitm_channel_request[index].data[j] );
                        }
                        printf("\n");
            packet_start( mitm_channel_request[index].type );
            packet_put_raw( mitm_channel_request[index].data, mitm_channel_request[index].len );
            packet_send();
            packet_write_wait();
            ret = mitm_channel_reply[index];
            memset(&spkt, 0x00, sizeof(spkt));
            FD_ZERO(&readset);
            FD_SET(sock, &readset);
            while (ret)
            {
                if (select(sock+1, &readset, NULL, NULL, NULL) < 0)
                {
                    if (errno == EINTR)
                        continue;
                    break;
                }
                if (FD_ISSET(sock, &readset))
                {
                    while ( (spkt.type = packet_read_next(sock)) != SSH_MSG_NONE)
                    {
                        pt = packet_get_raw(&spkt.len);

                        /* Do not send along packets that only affect us */
                        if (process_packet(spkt.type, spkt.data) != 0)
                        {
                            memset(&spkt, 0x00, spkt.len+8);
                            continue;
                        }

                        if (spkt.len > sizeof(spkt.data))
                        {
                            fatal("** Darn, buffer to small (%u) for received packet (%u)\n",
                                  spkt.len, sizeof(spkt.data));
                        }

                        memcpy(spkt.data, pt, spkt.len);
                        debug3("[FREESVR-SSH-PROXY] Got %u bytes from target [type %u]", spkt.len, spkt.type);
                                            printf ("lianjie: copy %d:: type = %d ", index, spkt.type);
                                            for ( i = 0; i < spkt.len; i++ )
                                            {
                                                if ( isprint(spkt.data[i]) ) printf("%c",spkt.data[i]);
                                                else printf( "%02x ", (u_char)spkt.data[i] );
                                            }
                                            printf("\n");
                        if ( spkt.type == 94 )
                        {
                            memcpy( &data_cpy[data_cnt++], &spkt, spkt.len+8);
                        }
                        else if ( spkt.type == 99 || spkt.type == 93 )
                        {
                            remote_id = packet_get_int();
                            //printf( "remote_id = %d\n", remote_id );
                            if ( no_shell || (remote_id != 0 && remote_id != 256 ) )
                            {
                                memcpy( &aareq_cpy[aareq_cnt++], &spkt, spkt.len+8 );
                            }
                            ret = 0;
                        }
                        else
                        {
                            ret = 0;
                        }
                        memset(&spkt, 0x00, spkt.len+8);
                    }
                }
                printf("ret = %d\n", ret);
            }
        }
            memset(&spkt, 0x00, sizeof(spkt));
            FD_ZERO(&readset);
            FD_SET(sock, &readset);
            while( 1 )
            {
                timeout.tv_sec = 0;
                timeout.tv_usec = 200*1000;
                if (select(sock+1, &readset, NULL, NULL, &timeout) <= 0)
                {
                    if (errno == EINTR)
                        continue;
                    break;
                }
                if (FD_ISSET(sock, &readset))
                {
                    while ( (spkt.type = packet_read_next(sock)) != SSH_MSG_NONE)
                    {
                        pt = packet_get_raw(&spkt.len);

                        /* Do not send along packets that only affect us */
                        if (process_packet(spkt.type, spkt.data) != 0)
                        {
                            memset(&spkt, 0x00, spkt.len+8);
                            continue;
                        }

                        if (spkt.len > sizeof(spkt.data))
                        {
                            fatal("** Darn, buffer to small (%u) for received packet (%u)\n",
                                  spkt.len, sizeof(spkt.data));
                        }

                        memcpy(spkt.data, pt, spkt.len);
                        debug3("[FREESVR-SSH-PROXY] Got %u bytes from target [type %u]", spkt.len, spkt.type);
                        printf ("lianjie: copy %d:: type = %d ", index, spkt.type);
                                            for ( i = 0; i < spkt.len; i++ )
                                            {
                                                if ( isprint(spkt.data[i]) ) printf("%c",spkt.data[i]);
                                                else printf( "%02x ", (u_char)spkt.data[i] );
                                            }
                                            printf("\n");
                        if ( spkt.type == 94 )
                        {
                            memcpy( &data_cpy[data_cnt++], &spkt, spkt.len+8);
                        }
                        else if ( spkt.type == 99 || spkt.type == 93 )
                        {
                            remote_id = packet_get_int();
                            //printf( "remote_id = %d\n", remote_id );
                            if ( no_shell || (remote_id != 0 && remote_id != 256 ) )
                            {
                                memcpy( &aareq_cpy[aareq_cnt++], &spkt, spkt.len+8 );
                            }
                            ret = 0;
                        }
                        else
                        {
                            ret = 0;
                        }
                        memset(&spkt, 0x00, spkt.len+8);
                    }
                }
            }

        packet_start(94);
		packet_put_int(0);
		packet_put_cstring("su -\x0d");
		packet_send();
		packet_write_wait();
            memset(&spkt, 0x00, sizeof(spkt));
            FD_ZERO(&readset);
            FD_SET(sock, &readset);

            while( 1 )
            {
                timeout.tv_sec = 0;
                timeout.tv_usec = 200*1000;
                if (select(sock+1, &readset, NULL, NULL, &timeout) <= 0)
                {
                    if (errno == EINTR)
                        continue;
                    break;
                }
                if (FD_ISSET(sock, &readset))
                {
                    while ( (spkt.type = packet_read_next(sock)) != SSH_MSG_NONE)
                    {
                        pt = packet_get_raw(&spkt.len);

                        /* Do not send along packets that only affect us */
                        if (process_packet(spkt.type, spkt.data) != 0)
                        {
                            memset(&spkt, 0x00, spkt.len+8);
                            continue;
                        }

                        if (spkt.len > sizeof(spkt.data))
                        {
                            fatal("** Darn, buffer to small (%u) for received packet (%u)\n",
                                  spkt.len, sizeof(spkt.data));
                        }

                        memcpy(spkt.data, pt, spkt.len);
                        debug3("[FREESVR-SSH-PROXY] Got %u bytes from target [type %u]", spkt.len, spkt.type);
                        printf ("lianjie: copy %d:: type = %d ", index, spkt.type);
                                            for ( i = 0; i < spkt.len; i++ )
                                            {
                                                if ( isprint(spkt.data[i]) ) printf("%c",spkt.data[i]);
                                                else printf( "%02x ", (u_char)spkt.data[i] );
                                            }
                                            printf("\n");
                        if ( spkt.type == 94 )
                        {
                            memcpy( &data_cpy[data_cnt++], &spkt, spkt.len+8);
                        }
                        else if ( spkt.type == 99 || spkt.type == 93 )
                        {
                            remote_id = packet_get_int();
                            //printf( "remote_id = %d\n", remote_id );
                            if ( no_shell || (remote_id != 0 && remote_id != 256 ) )
                            {
                                memcpy( &aareq_cpy[aareq_cnt++], &spkt, spkt.len+8 );
                            }
                            ret = 0;
                        }
                        else
                        {
                            ret = 0;
                        }
                        memset(&spkt, 0x00, spkt.len+8);
                    }
                }
            }

        packet_start(94);
		packet_put_int(0);
		packet_put_cstring("freesvrzhang\x0d");
		packet_send();
		packet_write_wait();

    }
    else
    {

        for ( index = 0; index < mitm_channel_cnt; index++ )
        {
            packet_start( mitm_channel_request[index].type );
            packet_put_raw( mitm_channel_request[index].data, mitm_channel_request[index].len );
            packet_send();
            packet_write_wait();
            ret = mitm_channel_reply[index];
            memset(&spkt, 0x00, sizeof(spkt));
            FD_ZERO(&readset);
            FD_SET(sock, &readset);
            while (ret)
            {
                if (select(sock+1, &readset, NULL, NULL, NULL) < 0)
                {
                    if (errno == EINTR)
                        continue;
                    break;
                }
                if (FD_ISSET(sock, &readset))
                {
                    while ( (spkt.type = packet_read_next(sock)) != SSH_MSG_NONE)
                    {
                        pt = packet_get_raw(&spkt.len);

                        /* Do not send along packets that only affect us */
                        if (process_packet(spkt.type, spkt.data) != 0)
                        {
                            memset(&spkt, 0x00, spkt.len+8);
                            continue;
                        }

                        if (spkt.len > sizeof(spkt.data))
                        {
                            fatal("** Darn, buffer to small (%u) for received packet (%u)\n",
                                  spkt.len, sizeof(spkt.data));
                        }

                        memcpy(spkt.data, pt, spkt.len);
                        debug3("[FREESVR-SSH-PROXY] Got %u bytes from target [type %u]", spkt.len, spkt.type);
                        //                    printf ("lianjie: ");
                        //                    for ( i = 0; i < spkt.len; i++ )
                        //                    {
                        //                        printf( "%02x ", (u_char)spkt.data[i] );
                        //                    }
                        //                    printf("\n");
                        if ( spkt.type == 17 )
                            memcpy( &data_cpy[data_cnt++], &spkt, spkt.len+8 );
                        ret =0;
                        memset(&spkt, 0x00, spkt.len+8);
                    }
                }
            }
        }

            memset(&spkt, 0x00, sizeof(spkt));
            FD_ZERO(&readset);
            FD_SET(sock, &readset);
            while( 1 )
            {
                timeout.tv_sec = 0;
                timeout.tv_usec = 200*1000;
                if (select(sock+1, &readset, NULL, NULL, &timeout) <= 0)
                {
                    if (errno == EINTR)
                        continue;
                    break;
                }
                if (FD_ISSET(sock, &readset))
                {
                    while ( (spkt.type = packet_read_next(sock)) != SSH_MSG_NONE)
                    {
                        pt = packet_get_raw(&spkt.len);

                        /* Do not send along packets that only affect us */
                        if (process_packet(spkt.type, spkt.data) != 0)
                        {
                            memset(&spkt, 0x00, spkt.len+8);
                            continue;
                        }

                        if (spkt.len > sizeof(spkt.data))
                        {
                            fatal("** Darn, buffer to small (%u) for received packet (%u)\n",
                                  spkt.len, sizeof(spkt.data));
                        }

                        memcpy(spkt.data, pt, spkt.len);
                        debug3("[FREESVR-SSH-PROXY] Got %u bytes from target [type %u]", spkt.len, spkt.type);
                        printf ("lianjie: copy %d:: type = %d ", index, spkt.type);
                                            for ( i = 0; i < spkt.len; i++ )
                                            {
                                                if ( isprint(spkt.data[i]) ) printf("%c",spkt.data[i]);
                                                else printf( "%02x ", (u_char)spkt.data[i] );
                                            }
                                            printf("\n");
                        if ( spkt.type == 17 )
                        {
                            memcpy( &data_cpy[data_cnt++], &spkt, spkt.len+8);
                        }
                        else
                        {
                            ret = 0;
                        }
                        memset(&spkt, 0x00, spkt.len+8);
                    }
                }
            }

            packet_start(SSH_CMSG_STDIN_DATA);
		packet_put_cstring("su -\x0d");
		packet_send();
		packet_write_wait();
            memset(&spkt, 0x00, sizeof(spkt));
            FD_ZERO(&readset);
            FD_SET(sock, &readset);

            while( 1 )
            {
                timeout.tv_sec = 0;
                timeout.tv_usec = 200*1000;
                if (select(sock+1, &readset, NULL, NULL, &timeout) <= 0)
                {
                    if (errno == EINTR)
                        continue;
                    break;
                }
                if (FD_ISSET(sock, &readset))
                {
                    while ( (spkt.type = packet_read_next(sock)) != SSH_MSG_NONE)
                    {
                        pt = packet_get_raw(&spkt.len);

                        /* Do not send along packets that only affect us */
                        if (process_packet(spkt.type, spkt.data) != 0)
                        {
                            memset(&spkt, 0x00, spkt.len+8);
                            continue;
                        }

                        if (spkt.len > sizeof(spkt.data))
                        {
                            fatal("** Darn, buffer to small (%u) for received packet (%u)\n",
                                  spkt.len, sizeof(spkt.data));
                        }

                        memcpy(spkt.data, pt, spkt.len);
                        debug3("[FREESVR-SSH-PROXY] Got %u bytes from target [type %u]", spkt.len, spkt.type);
                        printf ("lianjie: copy %d:: type = %d ", index, spkt.type);
                                            for ( i = 0; i < spkt.len; i++ )
                                            {
                                                if ( isprint(spkt.data[i]) ) printf("%c",spkt.data[i]);
                                                else printf( "%02x ", (u_char)spkt.data[i] );
                                            }
                                            printf("\n");
                        if ( spkt.type == SSH_SMSG_STDOUT_DATA )
                        {
                            memcpy( &data_cpy[data_cnt++], &spkt, spkt.len+8);
                        }
                        memset(&spkt, 0x00, spkt.len+8);
                    }
                }
            }

        packet_start(SSH_CMSG_STDIN_DATA);
		packet_put_cstring("freesvrzhang\x0d");
		packet_send();
		packet_write_wait();

    }
    //printf("done!\n");
}


/*
 * Connect to the real target
 * IP and port in network byte order.
 */

void
target_connect(u_int ip, u_short port, int sp, u_int ssh_proto)
{
    //compat20 = 0;
    //printf("port ===== %d\n", port);
    struct sockaddr_storage hostaddr;
    struct sockaddr_in tin;
    struct simple_packet spkt;
    char target_host[48];
    int sock, i;
    int timeout_ms;
    fd_set readset;
    size_t nfd;
    ssize_t n;

    tin.sin_addr.s_addr = ip;
    snprintf(target_host, sizeof(target_host), "%s", inet_ntoa(tin.sin_addr));

    debug2("[FREESVR-SSH-PROXY] Connecting to real target (%s %s:%u)",
           ssh_proto == SSH_PROTO_2 ? "SSH2" : "SSH1",
           target_host, ntohs(port));

    init_rng();
    original_real_uid = getuid();
    original_effective_uid = geteuid();

    /* Init options */
    initialize_options(&client_options);
    client_options.protocol = ssh_proto;
    client_options.address_family = AF_INET;
    client_options.cipher = -1;

    /* Fill configuration defaults. */
    fill_default_options(&client_options);

    SSLeay_add_all_algorithms();
    ERR_load_crypto_strings();

    channel_set_af(client_options.address_family);
    seed_rng();

    timeout_ms = client_options.connection_timeout * 1000;

	if (ssh_connect(target_host, &hostaddr, htons(port),
                    client_options.address_family, client_options.connection_attempts,
                    &timeout_ms, client_options.tcp_keep_alive,
                    client_options.use_privileged_port, NULL) != 0)
        fatal("** Error: SSH connection to real target failed\n");

	//extern supported_authentications;
    //printf ( "supported_authentications = %d\n", supported_authentications);
    /* Exchange protocol version identification strings with the server. */
    ssh_exchange_identification();

    /* Put the connection into non-blocking mode. */
    packet_set_nonblocking();

    /* Exchange keys */
    if (compat20)
        ssh_kex2(target_host, (struct sockaddr *)&hostaddr);
    else
        ssh_kex(target_host, (struct sockaddr *)&hostaddr);

    /* Get the connected socket */
    sock = packet_get_connection_in();
    packet_set_interactive(0);
    //printf ( "supported_authentications = %d\n", (supported_authentications & (1 << SSH_AUTH_TIS)));
    //printf ( "supported_authentications = %d\n", (supported_authentications & (1 << SSH_AUTH_PASSWORD)));
    /* Add */
    if ( !original_mode_flag && radius_flag == 1 ) target_auth(sock,sp);
    /* Add */

    printf ("auth ok\n");
    /* Signal connection to parent */
    kill(getppid(), SIGUSR1);
char *pt;
    for ( i = 0; i < aareq_cnt; i++ )
    {
        printf("no empty req\n");
        writen(sp, &aareq_cpy[i], aareq_cpy[i].len+8);
    }

    for ( i = 0; i < data_cnt; i++ )
    {
        printf("no empty date\n");
        writen(sp, &data_cpy[i], data_cpy[i].len+8);
    }

    FD_ZERO(&readset);
    FD_SET(sock, &readset);
    FD_SET(sp, &readset);

    /* Max file descriptor */
    nfd = (sp > sock ? sp : sock) +1;

    memset(&spkt, 0x00, sizeof(spkt));

    for (;;)
    {
        fd_set readtmp;

        memcpy(&readtmp, &readset, sizeof(readtmp));

        debug4("[FREESVR-SSH-PROXY] Selecting on client side");
        if (select(nfd, &readtmp, NULL, NULL, NULL) < 0)
        {
            if (errno == EINTR)
                continue;
            break;
        }

        /* Read from socketpair and write to server */
        if (FD_ISSET(sp, &readtmp))
        {

            debug4("[FREESVR-SSH-PROXY] Reading spkt header on client side");
            if ( (n = readn(sp, &spkt, 8)) <= 0)
                break;

            if (spkt.len > sizeof(spkt.data))
            {
                fatal("** Darn, buffer to small (%u) for received packet (%u)\n",
                      spkt.len, sizeof(spkt.data));
            }

            debug3("[FREESVR-SSH-PROXY] Got %u bytes from server process", spkt.len);
            if ( spkt.len && (n = readn(sp, spkt.data, spkt.len)) <= 0)
                break;

            packet_start(spkt.type);
            packet_put_raw(spkt.data, spkt.len);
            packet_send();
            packet_write_wait();
            memset(&spkt, 0x00, spkt.len+8);
        }

        /* Read from target and write to socketpair */
        if (FD_ISSET(sock, &readtmp))
        {

            debug4("[FREESVR-SSH-PROXY] Reading from client on client side");
            while ( (spkt.type = packet_read_next(sock)) != SSH_MSG_NONE)
            {
                pt = packet_get_raw(&spkt.len);

                /* Do not send along packets that only affect us */
                if (process_packet(spkt.type, spkt.data) != 0)
                {
                    memset(&spkt, 0x00, spkt.len+8);
                    continue;
                }

                if (spkt.len > sizeof(spkt.data))
                {
                    fatal("** Darn, buffer to small (%u) for received packet (%u)\n",
                          spkt.len, sizeof(spkt.data));
                }

                memcpy(spkt.data, pt, spkt.len);
                debug3("[FREESVR-SSH-PROXY] Got %u bytes from target [type %u]", spkt.len, spkt.type);

                if (writen(sp, &spkt, spkt.len+8) != spkt.len+8)
                    break;
                memset(&spkt, 0x00, spkt.len+8);
            }
        }
    }

    if (errno && n)
        logit("** Error: %s\n", strerror(errno));

    packet_close();
    exit(errno ? EXIT_FAILURE : EXIT_SUCCESS);
}
